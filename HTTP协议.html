<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="一 HTTP概述 HTTP（hypertext transport protocol），即超文本传输协议。这个协议详细规定了浏览器和万维网服务器之间互相通信的规则。 HTTP就是一个通信规则，通信规则" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Http协议 - Yuan先生 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=PyyhYDRKBG1sYtpoHme_xHO5AMd5iN57I45iBKF8FVY" />
    <link id="MainCss" rel="stylesheet" href="/skins/summergarden/bundle-summergarden.min.css?v=X4bFXeVITa4R62KibBcxY9PyNj-MkkV0-IpC8y8yg_Q" />
    <link type="text/css" rel="stylesheet" href="https://www.cnblogs.com/yuanchenqi/custom.css?v=uTRTahVBjVwerqbmuH55G1&#x2B;IShg=" />
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/summergarden/bundle-summergarden-mobile.min.css?v=-QJralHuYdZVDw2zivi4j5fUWp9jAHwpSH6TIdmjbwI" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/yuanchenqi/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/yuanchenqi/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/yuanchenqi/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=cjOfeR1PvDfGLdLnzp3exmJckxUGinvOfscZzbIEshk"></script>
    <script>
        var currentBlogId = 262677;
        var currentBlogApp = 'yuanchenqi';
        var cb_enable_mathjax = false;
        var isLogined = false;
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
	<a href="https://www.cnblogs.com/yuanchenqi/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>			
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/yuanchenqi/">Yuan先生</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		

			<ul id="navList">
				<li>
</li>
				<li>

</li>
				<li>


</li>
				<li>
</li>
				<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
				<li>

				
</li>
			</ul>



		<div class="blogStats">
			
			<!--done-->
随笔 - 
1&nbsp;
文章 - 
141&nbsp;
评论 - 
143&nbsp;



			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
<!--done-->
<div id="topics">
	<div class="post">
		<h1 class = "postTitle">
			
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yuanchenqi/articles/6000358.html">Http协议</a>

		</h1>
		<div class="clear"></div>
		<div class="postBody">
			
<div id="cnblogs_post_body" class="blogpost-body ">
    <h3 class="p1"><span class="s1"><strong>一 HTTP</strong><span class="s2"><strong>概述</strong></span></span></h3>
<p class="p1"><span class="s1">HTTP<span class="s2">（<span class="s3">hypertext transport protocol<span class="s2">），即超文本传输协议。这个协议<span class="s4">详细规定了浏览器和万维网服务器之间互相通信的规则。</span></span></span></span></span></p>
<p class="p2"><span class="s1">HTTP<span class="s3">就是一个通信规则，通信规则规定了客户端发送给服务器的内容格式，也规定了服务器发送给客户端的内容格式。其实我们要学习的就是这个两个格式！客户端发送给服务器的格式叫<span class="s1">&ldquo;<span class="s3">请求协议<span class="s1">&rdquo;<span class="s3">；服务器发送给客户端的格式叫<span class="s1">&ldquo;<span class="s3">响应协议<span class="s1">&rdquo;<span class="s3">。</span></span></span></span></span></span></span></span></span></span></p>
<p class="p2"><strong>特点：</strong></p>
<ul>
<li>HTTP叫超文本传输协议，基于请求/响应模式的！</li>
<li>HTTP是<span style="color: #800080;">无状态协议。</span></li>
</ul>
<p class="p2"><span class="s1">URL<span class="s3">：统一资源定位符，就是一个网址：</span></span><span class="s1"><span class="s2">协议名<span class="s3">://<span class="s2">域名<span class="s3">:<span class="s2">端口<span class="s3">/<span class="s2">路径，例如：<span class="s3">http://www.oldboy.cn:80/index.html</span></span></span></span></span></span></span></span></span></p>
<h3 class="p1"><span class="s1"><span class="s2">二 请求协议</span></span></h3>
<p class="p2"><span class="s2">请求协议的格式如下：</span></p>
<div class="cnblogs_code">
<pre>请求首行；  <span style="color: #008000;">//</span><span style="color: #008000;"> 请求方式 请求路径 协议和版本，例如：GET /index.html HTTP/1.1</span>
请求头信息；<span style="color: #008000;">//</span><span style="color: #008000;"> 请求头名称:请求头内容，即为key:value格式，例如：Host:localhost</span>
空行；     <span style="color: #008000;">//</span><span style="color: #008000;"> 用来与请求体分隔开</span>
请求体。   <span style="color: #008000;">//</span><span style="color: #008000;"> GET没有请求体，只有POST有请求体。</span></pre>
</div>
<p class="p1"><span class="s1">浏览器发送给服务器的内容就这个格式的，如果不是这个格式服务器将无法解读！在<span class="s2">HTTP<span class="s1">协议中，请求有很多请求方法，其中最为常用的就是<span class="s2">GET<span class="s1">和<span class="s2">POST<span class="s1">。不同的请求方法之间的区别，后面会一点一点的介绍。</span></span></span></span></span></span></span></p>
<h4 class="p1"><span class="s1">2.1<span class="s2">　<span class="s1">GET<span class="s2">请求</span></span></span></span></h4>
<p>HTTP默认的请求方法就是GET<br />&nbsp; &nbsp; &nbsp;* 没有请求体<br />&nbsp; &nbsp; &nbsp;* 数据必须在1K之内！<br />&nbsp; &nbsp; &nbsp;* GET请求数据会暴露在浏览器的地址栏中</p>
<p>GET请求常用的操作：<br />&nbsp; &nbsp; &nbsp; &nbsp;1. 在浏览器的地址栏中直接给出URL，那么就一定是GET请求<br />&nbsp; &nbsp; &nbsp; &nbsp;2. 点击页面上的超链接也一定是GET请求<br />&nbsp; &nbsp; &nbsp; &nbsp;3. 提交表单时，表单默认使用GET请求，但可以设置为POST</p>
<div class="cnblogs_code">
<pre>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*<span style="color: #008000;">/*</span><span style="color: #008000;">;q=0.8
Accept-Encoding:gzip, deflate, sdch
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:no-cache
Connection:keep-alive
Cookie:csrftoken=z5H43ZwARx7AIJ82OEizBOWbsAQA2LPk
Host:127.0.0.1:8090
Pragma:no-cache
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.89 Safari/537.36
Name
login/
1 requests&ensp;❘&ensp;737&thinsp;B transferred&ensp;❘&ensp;Finish: 5&thinsp;ms&ensp;❘&ensp;DOMContentLoaded: 14&thinsp;ms&ensp;❘&ensp;Load: 14&thinsp;ms
</span></pre>
</div>
<ul>
<li class="li1"><span class="s1"><span class="s1"><span class="s1"><span class="s1"><span class="s2">GET&nbsp;127.0.0.1:8090/login &nbsp;HTTP/1.1<span class="s3">：<span class="s4">GET<span class="s5">请求，请求服务器路径为 &nbsp;127.0.0.1:8090/login&nbsp;，协议为<span class="s4">1.1<span class="s5">；</span></span></span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Host:localhost<span class="s3">：<span class="s4">请求的主机名为<span class="s5">localhost<span class="s4">；</span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">*User-Agent: Mozilla/5.0 (<strong>Windows NT 5.1</strong>; rv:5.0) Gecko/20100101<strong> Firefox/5.0</strong><span class="s3">：<span class="s4">与浏览器和<span class="s5">OS<span class="s4">相关的信息。有些网站会显示用户的系统版本和浏览器版本信息，这都是通过获取<span class="s5">User-Agent<span class="s4">头信息而来的；</span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s1"><span class="s1"><span class="s2">&nbsp;</span></span></span></span><span class="s1"><span class="s2">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<span class="s3">：<span class="s4">告诉服务器，当前客户端可以接收的文档类型，其实这里包含了<span class="s5">*/*<span class="s4">，就表示什么都可以接收；</span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Language: zh-cn,zh;q=0.5<span class="s3">：<span class="s4">当前客户端支持的语言，可以在浏览器的工具<span class="s5"><span class="s4">选项中找到语言相关信息；</span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Encoding: gzip, deflate<span class="s3">：<span class="s4">支持的压缩格式。数据在网络上传递时，可能服务器会把数据压缩后再发送；</span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s2">Accept-Charset: GB2312,utf-8;q=0.7,*;q=0.7<span class="s3">：<span class="s4">客户端支持的编码；</span></span></span></span></li>
<li class="li2"><span class="s5"><span class="s6">Connection: keep-alive<span class="s7">：<span class="s3">客户端支持的链接方式，保持一段时间链接，默认为<span class="s2">3000ms<span class="s3">；</span></span></span></span></span></span></li>
<li class="li2"><span class="s5"><span class="s6">Cookie: JSESSIONID=369766FDF6220F7803433C0B2DE36D98<span class="s7">：<span class="s3">因为不是第一次访问这个地址，所以会在请求中把上一次服务器响应中发送过来的<span class="s2">Cookie<span class="s3">在请求中一并发送去过；这个<span class="s2">Cookie<span class="s3">的名字为<span class="s2">JSESSIONID。</span></span></span></span></span></span></span></span></span></li>
</ul>
<h4 class="p1"><span class="s1">注意</span></h4>
<div class="cnblogs_code" onclick="cnblogs_code_show('3ccadf7d-f015-4e99-8123-245a2f97e59a')"><img id="code_img_closed_3ccadf7d-f015-4e99-8123-245a2f97e59a" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_3ccadf7d-f015-4e99-8123-245a2f97e59a" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('3ccadf7d-f015-4e99-8123-245a2f97e59a',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_3ccadf7d-f015-4e99-8123-245a2f97e59a" class="cnblogs_code_hide">
<pre><span style="color: #000000;">HTTP无状态：无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页
和你之前打开这个服务器上的网页之间没有任何联系
如果你要实现一个购物车，需要借助于Cookie或Session或服务器端API（如NSAPI </span><span style="color: #0000ff;">and</span><span style="color: #000000;"> ISAPI）记录这些信息，请求服务器结算页面时同时将这些信息提交到服务器
当你登录到一个网站时，你的登录状态也是由Cookie或Session来&ldquo;记忆&rdquo;的，因为服务器并不知道你是否登录
优点：服务器不用为每个客户端连接分配内存来记忆大量状态，也不用在客户端失去连接时去清理内存，以更高效地去处理WEB业务
缺点：客户端的每次请求都需要携带相应参数，服务器需要处理这些参数

容易犯的误区：
</span>1<span style="color: #000000;">、HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）
</span>2、从HTTP/1.1起，默认都开启了Keep-<span style="color: #000000;">Alive，保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输
HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接
</span>3、Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间</pre>
</div>
<span class="cnblogs_code_collapse">View Code</span></div>
<h4 class="p1"><span class="s1">2.2<span class="s2">　<span class="s1">POST<span class="s2">请求</span></span></span></span></h4>
<p style="margin-left: 30px;">(1). 数据不会出现在地址栏中<br />(2). 数据的大小没有上限<br />(3). 有请求体<br />(4). 请求体中如果存在中文，会使用URL编码！</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">username=%E5%BC%A0%E4%B8%89&amp;password=123
</pre>
</div>
<div class="cnblogs_code" onclick="cnblogs_code_show('fe1a087a-6bc0-4699-b593-6690c7176d8b')"><img id="code_img_closed_fe1a087a-6bc0-4699-b593-6690c7176d8b" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_fe1a087a-6bc0-4699-b593-6690c7176d8b" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('fe1a087a-6bc0-4699-b593-6690c7176d8b',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_fe1a087a-6bc0-4699-b593-6690c7176d8b" class="cnblogs_code_hide">
<pre>我们都知道Http协议中参数的传输是"key=value"这种简直对形式的，如果要传多个参数就需要用&ldquo;&amp;&rdquo;符号对键值对进行分割。如"?name1=value1&amp;name2=value2"，这样在服务端在收到这种字符串的时候，会用&ldquo;&amp;&rdquo;分割出每一个参数，然后再用&ldquo;=<span style="color: #000000;">&rdquo;来分割出参数值。

 

针对&ldquo;name1</span>=value1&amp;name2=<span style="color: #000000;">value2&rdquo;我们来说一下客户端到服务端的概念上解析过程: 
  上述字符串在计算机中用ASCII吗表示为： 
  6E616D6531 3D 76616C756531 </span>26<span style="color: #000000;"> 6E616D6532 3D 76616C756532。 
   6E616D6531：name1 
   3D：</span>=<span style="color: #000000;"> 
   76616C756531：value1 
   </span>26：&amp;<span style="color: #000000;">
   6E616D6532：name2 
   3D：</span>=<span style="color: #000000;"> 
   76616C756532：value2 
   服务端在接收到该数据后就可以遍历该字节流，首先一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再想后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。

   现在有这样一个问题，如果我的参数值中就包含</span>=或&amp;<span style="color: #000000;">这种特殊字符的时候该怎么办。 
比如说&ldquo;name1</span>=value1&rdquo;,其中value1的值是&ldquo;va&amp;lu=e1&rdquo;字符串，那么实际在传输过程中就会变成这样&ldquo;name1=va&amp;lu=<span style="color: #000000;">e1&rdquo;。我们的本意是就只有一个键值对，但是服务端会解析成两个键值对，这样就产生了奇异。

如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码 
   URL编码只是简单的在特殊字符的各个字节前加上</span>%，例如，我们对上述会产生奇异的字符进行URL编码后结果：&ldquo;name1=va%26lu%3D&rdquo;，这样服务端会把紧跟在&ldquo;%&rdquo;后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。</pre>
</div>
<span class="cnblogs_code_collapse">为什么要进行URL编码</span></div>
<p>使用表单可以发POST请求，但表单默认是GET</p>
<div class="cnblogs_Highlighter">
<pre class="brush:javascript;gutter:true;">&lt;form action="" method="post"&gt;
  关键字：&lt;input type="text" name="keyword"/&gt;
  &lt;input type="submit" value="提交"/&gt;
&lt;/form&gt;
</pre>
</div>
<p class="p1"><span class="s1">输入yuan<span class="s2"><span class="s1">后点击提交，查看请求内容如下：</span></span></span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">Request Headers
Accept:text</span>/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*<span style="color: #008000;">/*</span><span style="color: #008000;">;q=0.8
Accept-Encoding:gzip, deflate
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:no-cache
Connection:keep-alive
Content-Length:13
Content-Type:application/x-www-form-urlencoded
Cookie:csrftoken=z5H43ZwARx7AIJ82OEizBOWbsAQA2LPk
Host:127.0.0.1:8090
Origin:http://127.0.0.1:8090
Pragma:no-cache
Referer:http://127.0.0.1:8090/login/
Upgrade-Insecure-Requests:1
User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) <br />           AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.89 Safari/537.36
<br />Form Data
username:yuan<br /></span></pre>
</div>
<p class="p1"><span class="s1">POST<span class="s2">请求是可以有体的，而<span class="s1">GET<span class="s2">请求不能有请求体。</span></span></span></span></p>
<ul>
<li class="li1"><span class="s1"><span class="s2"><span style="color: #800080;"><strong>Referer</strong></span><span class="s3"><span style="color: #800080;">:</span> http://localhost:8080/hello/index.jsp<span class="s4">：<span class="s5">请求来自哪个页面，例如你在百度上点击链接到了这里，那么<span class="s6">Referer:http://www.baidu.com<span class="s5">；如果你是在浏览器的地址栏中直接输入的地址，那么就没有<span class="s6">Referer<span class="s5">这个请求头了；</span></span></span></span></span></span></span></span></span></li>
<li class="li2"><span class="s1"><span class="s3">Content-Type: application/x-www-form-urlencoded<span class="s4">：<span class="s5">表单的数据类型，说明会使用<span class="s6">url<span class="s5">格式编码数据；<span class="s6">url<span class="s5">编码的数据都是以<span class="s6">&ldquo;%&rdquo;<span class="s5">为前缀，后面跟随两位的<span class="s6">16<span class="s5">进制。</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li class="li3"><span class="s7"><span class="s6">Content-Length:13<span class="s5">：<span class="s8">请求体的长度，这里表示<span class="s9">13<span class="s8">个字节。</span></span></span></span></span></span></li>
<li class="li4"><span class="s1"><span class="s10">keyword=hello<span class="s3">：<span class="s6">请求体内容！<span class="s11">hello<span class="s6">是在表单中输入的数据，<span class="s11">keyword<span class="s6">是表单字段的名字。</span></span></span></span></span></span></span></span></li>
</ul>
<div class="cnblogs_code" onclick="cnblogs_code_show('e1d8ab9e-a89a-4875-b2ed-5c8e3a50bf08')"><img id="code_img_closed_e1d8ab9e-a89a-4875-b2ed-5c8e3a50bf08" class="code_img_closed" src="https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif" alt="" /><img id="code_img_opened_e1d8ab9e-a89a-4875-b2ed-5c8e3a50bf08" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('e1d8ab9e-a89a-4875-b2ed-5c8e3a50bf08',event)" src="https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif" alt="" />
<div id="cnblogs_code_open_e1d8ab9e-a89a-4875-b2ed-5c8e3a50bf08" class="cnblogs_code_hide">
<pre><span style="color: #000000;">Referer请求头是比较有用的一个请求头，它可以用来做统计工作，也可以用来做防盗链。
统计工作：我公司网站在百度上做了广告，但不知道在百度上做广告对我们网站的访问量是否有影响，那么可以对每个请求中的Referer进行分析，如果Referer为百度的很多，那么说明用户都是通过百度找到我们公司网站的。
防盗链：我公司网站上有一个下载链接，而其他网站盗链了这个地址，例如在我网站上的index.html页面中有一个链接，点击即可下载JDK7.</span>0，但有某个人的微博中盗链了这个资源，它也有一个链接指向我们网站的JDK7.0，也就是说登录它的微博，点击链接就可以从我网站上下载JDK7.0，这导致我们网站的广告没有看，但下载的却是我网站的资源。这时可以使用Referer进行防盗链，在资源被下载之前，我们对Referer进行判断，如果请求来自本网站，那么允许下载，如果非本网站，先跳转到本网站看广告，然后再允许下载。</pre>
</div>
<span class="cnblogs_code_collapse">Referer的应用</span></div>
<h3 class="p1"><span class="s1"><strong>三</strong><span class="s2"><strong>　响应协议</strong></span></span></h3>
<h4 class="p2"><span class="s3">3.1<span class="s2">　响应内容</span></span></h4>
<p class="p3"><span class="s2">响应协议的格式如下：</span></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">响应首行；
响应头信息；
空行；
响应体。</span></pre>
</div>
<p class="p1"><span class="s1">响应内容是由服务器发送给浏览器的内容，浏览器会根据响应内容来显示。遇到</span>&lt;img src=''&gt;会开一个新的线程加载，所以有时图片多的话，内容会先显示出来，然后图片才一张张加载出来。</p>
<div class="cnblogs_code">
<pre>Request URL:http:<span style="color: #008000;">//</span><span style="color: #008000;">127.0.0.1:8090/login/</span>
<span style="color: #000000;">Request Method:GET
Status Code:</span>200<span style="color: #000000;"> OK
Remote Address:</span>127.0.0.1:8090<span style="color: #000000;">
Response Headers
view source
Content</span>-Type:text/html; charset=utf-8
Date:Wed, 26 Oct 2016 06:48:50<span style="color: #000000;"> GMT
Server:WSGIServer</span>/0.2 CPython/3.5.2<span style="color: #000000;">
X</span>-Frame-<span style="color: #000000;">Options:SAMEORIGIN

</span>&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="/login/" method="post"&gt;<span style="color: #000000;">
  用户名：</span>&lt;input type="text" name="username"/&gt;
  &lt;input type="submit" value="提交"/&gt;
&lt;/form&gt;    
&lt;/body&gt;
&lt;/html&gt;</pre>
</div>
<ul>
<li class="li1"><span class="s1"><span class="s2">HTTP/1.1 200 OK<span class="s3">：<span class="s4">响应协议为<span class="s5">HTTP1.1<span class="s4">，状态码为<span class="s5">200<span class="s4">，表示请求成功，<span class="s5">OK<span class="s4">是对状态码的解释；</span></span></span></span></span></span></span></span></span></span></li>
<li class="li2">Server:WSGIServer/0.2 CPython/3.5.2：<span class="s8">服务器的版本信息；</span></li>
<li class="li2"><span class="s6"><span class="s4">Content-Type: text/html;charset=UTF-8<span class="s7">：<span class="s8">响应体使用的编码为<span class="s9">UTF-8<span class="s8">；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Content-Length: 724<span class="s7">：<span class="s8">响应体为<span class="s9">724<span class="s8">字节；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Set-Cookie: JSESSIONID=C97E2B4C55553EAB46079A4F263435A4; Path=/hello<span class="s7">：<span class="s8">响应给客户端的<span class="s9">Cookie<span class="s8">；</span></span></span></span></span></span></li>
<li class="li3"><span class="s6"><span class="s4">Date: Wed, 25 Sep 2012 04:15:03 GMT<span class="s7">：<span class="s8">响应的时间，这可能会有<span class="s9">8<span class="s8">小时的时区差；</span></span></span></span></span></span></li>
</ul>
<h4 class="p1"><span class="s1">3.2<span class="s2">　<span class="s3">状态<span class="s2">码</span></span></span></span></h4>
<p class="p2"><span class="s2">响应头对浏览器来说很重要，它说明了响应的真正含义。例如<span class="s4">200<span class="s2">表示响应成功了，<span class="s4">302<span class="s2">表示重定向，这说明浏览器需要再发一个新的请求。</span></span></span></span></span></p>
<ul>
<li class="li3"><span class="s5"><span class="s4">200<span class="s2">：请求成功，浏览器会把响应体内容（通常是<span class="s4">html<span class="s2">）显示在浏览器中；</span></span></span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">404<span class="s2">：请求的资源没有找到，说明客户端错误的请求了不存在的资源；</span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">500<span class="s2">：请求资源找到了，但服务器内部出现了错误；</span></span></span></li>
<li class="li3"><span class="s5"><span class="s4">302<span class="s2">：重定向，当响应码为<span class="s4">302<span class="s2">时，表示服务器要求浏览器重新再发一个请求，服务器会发送一个响应头<span class="s4">Location<span class="s2">，它指定了新请求的<span class="s4">URL<span class="s2">地址；</span></span></span></span></span></span></span></span></span></li>
<li class="li1"><span class="s1"><span class="s1"><span class="s2">304<span class="s3">：</span></span></span></span>
<div class="cnblogs_code">
<pre>  当用户第一次请求index.html时，服务器会添加一个名为Last-<span style="color: #000000;">Modified响应头，这个头说明了
  index.html的最后修改时间，浏览器会把index.html内容，以及最后响应时间缓存下来。当用户第
  二次请求index.html时，在请求中包含一个名为If</span>-Modified-<span style="color: #000000;">Since请求头，它的值就是第一次请
  求时服务器通过Last</span>-<span style="color: #000000;">Modified响应头发送给浏览器的值，即index.html最后的修改时间，
  If</span>-Modified-<span style="color: #000000;">Since请求头就是在告诉服务器，我这里浏览器缓存的index.html最后修改时间是这个,
  您看看现在的index.html最后修改时间是不是这个，如果还是，那么您就不用再响应这个index.html
  内容了，我会把缓存的内容直接显示出来。而服务器端会获取If</span>-Modified-<span style="color: #000000;">Since值，与index.html
  的当前最后修改时间比对，如果相同，服务器会发响应码304，表示index.html与浏览器上次缓存的相
  同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明index.html已经做了修
  改，服务器会响应200。</span></pre>
</div>
</li>
</ul>
<h4 class="p1"><span class="s1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<img src="https://images2015.cnblogs.com/blog/877318/201610/877318-20161026162455218-1166783413.png" alt="" width="471" height="283" /></span></h4>
<h4 class="p1"><span class="s1">3.3<span class="s2">　其他响应头</span></span></h4>
<p class="p2"><span class="s2">告诉浏览器不要缓存的响应头：</span></p>
<ul>
<li class="li3"><span class="s3"><span class="s2">Expires: -1<span class="s4">；</span></span></span></li>
<li class="li3"><span class="s3"><span class="s2">Cache-Control: no-cache<span class="s4">；</span></span></span></li>
<li class="li3"><span class="s3"><span class="s2">Pragma: no-cache<span class="s4">；</span></span></span></li>
</ul>
<p class="p5"><span class="s4">自动刷新响应头，浏览器会在<span class="s2">3<span class="s4">秒之后请求<span class="s2">http://www.baidu.com<span class="s4">：</span></span></span></span></span></p>
<ul>
<li class="li3"><span class="s3"><span class="s2">Refresh: 3;url=http://www.baidu.com</span></span><span class="s2">&nbsp;</span></li>
</ul>
<h4 class="p7"><span class="s2">3.4<span class="s4">　<span class="s2">HTML<span class="s4">中指定响应头</span></span></span></span></h4>
<p class="p8"><span class="s4">在<span class="s2">HTMl<span class="s4">页面中可以使用<span class="s2">&lt;meta http-equiv="" content=""&gt;<span class="s4">来指定响应头，例如在<span class="s2">index.html<span class="s4">页面中给出<span class="s2">&lt;meta http-equiv="Refresh" content="3;url=http://www.baidu.com"&gt;<span class="s4">，表示浏览器只会显示<span class="s2">index.html<span class="s4">页面<span class="s2">3<span class="s4">秒，然后自动跳转到<span class="s2">http://www.baidu.com.</span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
		</div>
		<div class="postDesc">posted @ 
<span id="post-date">2016-10-26 14:52</span>&nbsp;
<a href="https://www.cnblogs.com/yuanchenqi/">Yuan先生</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditArticles.aspx?postid=6000358" rel="nofollow">
    编辑
</a>
<a href="javascript:void(0)" onclick="AddToWz(6000358);return false;">收藏</a></div>
	</div>
	
	
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = false, cb_blogId = 262677, cb_blogApp = 'yuanchenqi', cb_blogUserGuid = '6d0ad0ce-3cb7-e511-9fc1-ac853d9f53cc';
    var cb_entryId = 6000358, cb_entryCreatedDate = '2016-10-26 14:52', cb_postType = 2; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div></div>


	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			


			<div id="calendar"><div id="calendar"><div id="blog-calendar" style="display:none"></div></div>                
                    <script>loadBlogDefaultCalendar();</script></div>
			
			<DIV id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</DIV>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2019 Yuan先生
<br /><span id="poweredby">Powered by .NET Core 3.0.0 on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <script language="javascript" type="text/javascript">
//生成目录索引列表
function GenerateContentList()
{
  var jquery_h1_list = $('#cnblogs_post_body h1').not('.catListTitle').not('#blogTitle h1');//如果你的章节标题不是h4,只需要将这里的h4换掉即可
  if(jquery_h1_list.length>0)
  {
    var content = '<a name="_labelTop"></a>';
    content	+= '<div id="navCategory">';
    content	+= '<p style="font-size:25px;color:#EE1289;"><i>知识预览</i></p>';
    content	+= '<ul id="sortChapter">';
    for(var i =0;i<jquery_h1_list.length;i++)
    {
      var go_to_top = '<div style="text-align: right"><a href="#_labelTop">回到顶部</a><a name="_label' + i + '"></a></div>';
      $(jquery_h1_list[i]).before(go_to_top);
      var li_content = '<li><a href="#_label' + i + '"style="color: #003366;text-decoration:none;font-size:18px">' + $(jquery_h1_list[i]).text() + '</a></li>';
      content += li_content;
    }
    content	+= '</ul>';
    content	+= '</div>';
    if($('#cnblogs_post_body').length != 0 )
    {
      $($('#cnblogs_post_body')[0]).prepend(content);
    }
  }	
}
GenerateContentList();




$('#Header1_HeaderTitle').attr('href','https://i.cnblogs.com/EditArticles.aspx')

</script>
    </div>
</body>
</html>
