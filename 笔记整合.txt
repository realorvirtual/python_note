%S，分隔符.txt----------------------------------------------------------------------------------------------------
%s 字符串（也可以传数字）     %d数字      %f小数
msg="%s i am a good %s" % ("hi","boy")
%.6s表示保留6个字符。

s="%f"%(123.123456789)  ==123.123456默认保存后六位。
%.f，f前面加个点，表示只保留整数，%.8f保留8位小数。

也可以用key值，即%（name）s，后面加字典{“name”：“xu”}

还可以给字符串加颜色,以及左对齐（-）和右对齐（+）：
msg="i am \033[43;1m   %(name)+60s   \033[0m  my  hobby is alex" % {"name":"xu"}
+60表示右对齐，即从右边往左边数60个位置，其他字符必须在61个位置才能出现。
-60表示左对齐，即从左往右数60个位置，然后才能出现其他字符。(这里说的左右指的是%s所传入的字符串的第一个或者最后一个字符)

打印分隔符sep=“”：
print（“1”，“2”，“3”，sep=“：”）  ==1：2：3，当“”里面啥也不加时，输出为123，该方法为在字符中间加入分隔符。



configparser模块.txt----------------------------------------------------------------------------------------------------
configparser模块：针对配置文件进行操作   文件类型（.ini）
import configparser
config=configparser.ConfigParser()
config["DEFAULT"]={"a":1,"b":2}
with open("example.ini","w") as configfile:
    config.write(configfile)

config.sections()打印块名(除DEFAULT以外的块名)。
config["模块名]["key"]取出value值。

可以使用for循环对文件进行遍历。（遍历的时候默认会把DEFAULT遍历出来）
for value in config:

config.options("块名")将key名放到一个列表里面输出。
config.items("块名")将key跟value的组合放到一个列表里面输出。
config.get("块名"，"key名")取出vlue值，如果块里面没有相对应的key，那么函数会去DEFAULT里面查找相应的key，然后输出value。

config.add_section("块名")增加块。
config.set("块名","key","value")在存在的块里面增添key和value。
config.remove_section("块名")删除块。
config.remove_option("块名","key")删除key。

最后记得写上config.write(open("文件名","w"))这样才会把修改的内容保存下来。
for循环.txt----------------------------------------------------------------------------------------------------
可迭代对象：实现了迭代器协议的对象就是可迭代对象。
for 循环用的是迭代器协议，并不是索引。hashlib模块.txt----------------------------------------------------------------------------------------------------
hashlib模块：
md5加密：可以撞库破解
import hashlib
obj=hashlib.md5()
obj.update("hello".enconde("utf-8"))
print(obj.hexdigest())========5d41402abc4b2a76b9719d911017c592
可以这么做进行严格加密：
md5加上key值加密：obj.hashlib.md5("字符串"，"utf-8")。

obj.update("admin".encode("utf-8"))
obj.update("hello".encode("utf-8"))
像上面这样，如果同时有两条加密，那么第二条加密会受第一条的影响，上面第二条等效于obj.update("adminhello".encode("utf-8"))。
除了这个加密之外还有很多加密方法，例如sha256，调用方法为obj=hashlib.sha3_256()。
logging.txt----------------------------------------------------------------------------------------------------
logging模块：
武林传说
一般来说，直接使用logging模块只会在屏幕上显示而不会改变文件，使用了format格式化之后可以改变文件，
但不会在屏幕上显示，那怎么做才能既会显示又会改变文件呢？故事开始了......
import logging
logger=logging.getLogger()                       这个人会吸星大法
fh=logging.FileHandler("文件名.log","w")         这个人会改变文件
ch=logging.StreamHandle()                        这个人会改变屏幕
fm=logging.Formatter("%(asctime)s %(message)s")  给fh、ch两个人定一个需要显示和记录的内容
fh.setFormatter(fm)                              fh记下了内容
ch.setFormatter(fm)                              ch记下了内容
logger.addHandler(fh)                            logger吞了fh，学会了改变文件
logger.addHandler(ch)                            logger吞了ch，学会了改变屏幕
logger.setLevel("DEBUG")                         将level设置为debug
logger成为了大哥，下次直接调用，而不用再调用logging
logger.debug()
logger.info()
logger.warning()
logger.error()
logger.critical()

logger=logging.getLogger(“mylogger”)，括号里面可以填名称参数，mylogger为root的子对象，不填的话默认为root，即根对象。如果两个实例（logger、logger2）的名称参数相同的话，它们的设置也会同时设置，比如，
logger.setLevel("debug")，logger2.setLevel("info")，那么最终的level为info，即输出总共8条信息，只要同一个名称参数，创造出来的实例就是同一个（虽然名字不同）。
（创建mylogger的子对象：mylogger.son)
注意：如果父对象和子对象同时存在，父对象会正常地打印自己，而子对象会打印多次，父对象有多少级，子对象就会多打印多少次（例如有一个父级，子级就打印两次）。logging模块.txt----------------------------------------------------------------------------------------------------
logging模块：

import logging
logging.debug("debug message")==========一级
logging.info("info message")=============二级
logging.warning("warning message")========三级
logging.error("error message")============四级
logging.critical("critical message")==========五级
（打印的时候只会打印大于或等于设定级别的信息，不设定的话默认为第三级别，即warning级，此时打印，只会显示三条信息，即warning，error，critical）

调级方法：
logging.basicConfig(level=logging.DEBUG)========调级为第一级，此时打印将会把五条信息全部打印出来。
生成文本：
logging.basicConfig(filename="logger.log")========生成文本logger.log，并且会把信息存入文本当中，当你再次执行函数时，新的信息会被追加到上一次文本的末尾。
logging.basicConfig(filename="logger.log"，filemode="w")此时生成新的文本，重复执行函数时，旧的信息会被新的信息替代。
格式化：
logging.basicConfig(format="%(变量名称)s")，format函数会单独作用于每一级的信息。格式为%()s。
%（asctime）s ========代码执行到打印某一级信息时的当地时间。
%（lineno）d（s也行）========某一级信息的行号，例如它可以打印出logging.error在代码的哪一行。
%（message）s ========打印出每级的信息（logging.debug("也就是这个信息")
%（filename）s ========文件名（执行函数的文件，即代码所在的文件）
%（levelno）s========数字形式的日志级别
%（levelname）s========文本形式的日志级别
%（pathname）s========调用日志输出函数的模块的完整路径名，可能没有
%（filename）s========调用日志输出函数的模块的文件名
%（module）s========调用日志输出函数的模块名
%（funcName）s========调用日志输出函数的函数名
%（created）f========当前时间，用UNIX标准表示时间的浮点数表示
%（relativeCreated）s========输出日志信息时的，自Logger创建以来的
%（thread）s========线程ID，可能没有
%（threadName）s========线程名，可能没有
%（process）s========进程ID，可能没有




map，filter，匿名函数lambda.txt----------------------------------------------------------------------------------------------------
匿名函数：
lambda x:x+1，前面的x是输入参数，后面的x+1是表达式。
一般可以这么操作：
fun=lambada x:x+1
然后运行fun（8）就可以得到9了。

高阶函数意思就是在一个函数里面return另一个函数。

map函数：
map(lambda x:x**2，[1,2,3])，map函数前面的参数填函数，后面填可迭代对象。map是一个可迭代对象，如果想把它变成列表，可以使用list。
map函数会把判断和计算的结果保留下来。

filter函数：
filter(lambda x:x.endswith("oo",people)，前面的参数填函数，后面的参数填可迭代对象，函数判断如果满足前面函数的，即是true的就保存下来。
filter会过滤掉不符合的元素。

reduce（lambda x，y：x+y，num）把num的各个元素加起来得到一个总和，返回一个整体，比如num里面全是数字，那么返回一个整数。
map是处理num里面的单个元素，然后返回一个可迭代对象，而reduce处理的是一整个num，然后返回一整个数据，数字、列表或者元组。

os,sys,json模块.txt----------------------------------------------------------------------------------------------------
os，sys模块：
import sys,os
__file__==执行代码的文件路径。（找到的是当前文件的文件名，但在pycharm中，它会显示文件的路径，用cmd/python执行时显示的是文件名，所以使用时不太方便）
一般用这个找文件的绝对路径：os.path.abspath(__file__)。
往系统里面添加环境变量（临时，非永久性添加）：sys.path.append(文件路径)。

os模块是与系统交互的一个接口。
os.getcwd()当前文件所在的目录，非执行文件。
os.chdir("目录名")将当前脚本工作目录变为目录名对应的目录。（“..”）这样填表示返回上一层目录，chdir的功能相当于shell下cd。
os.curdir 返回当前目录。
os.pardir获取当前目录的父目录字符串名。
os.makedirs("文件名/文件名")在当前目录下面创建文件，可生成多个文件。
os.mkdir("文件名")生成单级目录。
os.removedirs("文件名")删除单级目录，如果上一级目录也为空则继续删除，一直递归。（只删除空文件）
os.rmdir("文件名")删除单级目录，若目录不为空则无法删除，报错，相当于shell中rmdir dirname。
os.listdir("文件名")列出指定目录下的所有文件和子目录，包括隐藏文件，呈现形式为列表。
os.remove("文件名")直接删除文件，不是目录哦。（删除目录的话会报错，报告拒绝访问）
os.stat("文件名")列出文件的一系列信息，比如何时创建（st_ctime创建时间），何时修改过文件（st_mtime上次修改的时间），何时保存（st_atime），文件大小（st_size）等。使用方法：os.stat("绝对路径").st_size。
os.path.split(path)将path分割成目录和文件名并组成一个tuple返回，比如“c:\a\b\c.py”===("c:\a\b","c.py")。
os.path.dirname(path)返回当前文件的目录，相当于split的第一个元素。
os.path.basename(path)返回当前文件的文件名，相当于split的第二个元素。
os.path.exists(path)如果path存在，返回True，否则返回False。
os.path.isabs(path)判断是否为绝对路径。
os.path.isfile(path)判断path是否为一个文件（文件不是目录哦）。
os.path.isdir(path)判断path是否为一个目录。
os.path.join(x,y)将路径x和y拼接起来。
os.path.getatime(path)返回path所对应的文件或者目录最后保存的时间。
os.path.getmtime(path)返回path所对应的文件或者目录最后修改的时间。
os.sep输出操作系统特定的路径分隔符，win为\\，Linux为/
os.linesep输出当前平台使用的行终止符，win为\t\n，Linux为\n
os.pathsep输出用于分割文件路径的字符串，win为;，Linux为：
os.rename("oldname","newname")重命名文件/目录。注意：该操作基于当前操作目录，且里面的参数可以填写路径。
os.getpid()返回当前进程的进程号。
os.getppid()返回当前进程的父进程号。
sys模块：
sys.exit(0)正常退出程序。
sys.version获取python解释程序的版本信息。
sys.path返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值。
sys.paltform返回操作系统平台名称。
sys.stdout.wirte("#")可以用这个来做进度条，例如使用for循环打印10个#，跟print不同的是，每次print完成之后会换行，而这个不会，它会紧接着打印出来，并且在同一行显示。
sys.stdout.wirte("\r#")在前面加上\r，表示将光标放在行头。因此可以做成进度条，一般形式sys.stdout.write("\r%s%% %s"%(x,"<"*x))
如果将f=open("路径","w")复制给sys.stdout，即sys.stdout=f，那么调用print("内容")时，会把print中输入的内容写入到文件当中。
json模块：
json可以处理很多语言的很多数据类型，相当于各种据类型的规范。
json.dumps(数据，比如说字典)==“数据”，相当于执行了str（数据）。
json.loads(数据，该数据为字符串)==将字符串数据转换回原数据。

在文件处理时可以使用dump，load：
json.dump(数据，变量)，例如json.dump("hello",f)，相当于执行了f.write（json.dump("hello")）。
data=json.loads(f.read())这句话就可以用load来简化，data=json.load(f)。

pickle模块：
pickle.dumps，pickle.loads这两个函数跟json功能上是相似的，只不过pickle会把数据转换为二进制，而json将数据转换为字符串。

pycharm快捷键.txt----------------------------------------------------------------------------------------------------
1、编辑（Editing）

Ctrl + Space 基本的代码完成（类、方法、属性）

Ctrl + Alt + Space 快速导入任意类

Ctrl + Shift + Enter 语句完成

Ctrl + P 参数信息（在方法中调用参数）

Ctrl + Q 快速查看文档

F1 Web帮助文档主页

Shift + F1 选中对象的Web帮助文档

Ctrl + 悬浮/单击鼠标左键 简介/进入代码定义

Ctrl + Z 撤销上次操作

Ctrl + Shift + Z 重做,恢复上次的撤销

Ctrl + F1 显示错误描述或警告信息

Alt + Insert 自动生成代码

Ctrl + O 重新方法

Ctrl + Alt + T 选中

Ctrl + / 行注释/取消注释

Ctrl + Shift + / 块注释

Ctrl + W 选中增加的代码块

Ctrl + Shift + W 回到之前状态

Ctrl + Shift + ]/[ 选定代码块结束、开始

Alt + Enter 快速修正

Ctrl + Alt + L 代码格式化

Ctrl + Alt + O 优化导入

Ctrl + Alt + I 自动缩进

Tab / Shift + Tab 缩进、不缩进当前行

Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板

Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板

Ctrl+V/Shift+Insert 从剪贴板粘贴

Ctrl + Shift + V 从最近的缓冲区粘贴

Ctrl + D 复制选定的区域或行

Ctrl + Y 删除选定的行

Ctrl + Shift + J 添加智能线

Ctrl + Enter 智能线切割

Shift + Enter 另起一行

Ctrl + Shift + U 在选定的区域或代码块间切换

Ctrl + Delete 删除到字符结束

Ctrl + Backspace 删除到字符开始

Ctrl + Numpad+/- 展开/折叠代码块（当前位置：函数、注释等）

Ctrl + Shift + Numpad+/- 展开/折叠所有代码块

Ctrl + F4 关闭运行的选项卡

2、查找/替换(Search/Replace)

F3 下一个

Shift + F3 前一个

Ctrl + R 替换

Ctrl + Shift + R 全局替换

Ctrl + Shift + F 全局查找（可以在整个项目中查找某个字符串什么的，如查找某个函数名）

连续敲击两次Shift键 查找函数

3、运行(Running)

Alt + Shift + F10 运行模式配置

Alt + Shift + F9 调试模式配置

Shift + F10 运行

Shift + F9 调试

Ctrl + Shift + F10 运行编辑器配置

Ctrl + Alt + R 运行manage.py任务

4、调试(Debugging)

F8 跳过

F7 进入

Shift + F8 退出

Alt + F9 运行游标

Alt + F8 验证表达式

Ctrl + Alt + F8 快速验证表达式

F9 恢复程序

Ctrl + F8 断点开关

Ctrl + Shift + F8 查看断点

5、导航(Navigation)

Ctrl + N 跳转到类

Ctrl + Shift + N 跳转到符号

Alt + Right/Left 跳转到下一个、前一个编辑的选项卡（代码文件）

Alt + Up/Down跳转到上一个、下一个方法

F12 回到先前的工具窗口

Esc 从工具窗口回到编辑窗口

Shift + Esc 隐藏运行的、最近运行的窗口

Ctrl + Shift + F4 关闭主动运行的选项卡

Ctrl + G 查看当前行号、字符号

Ctrl + E 在当前文件弹出最近使用的文件列表

Ctrl+Alt+Left/Right 后退、前进

Ctrl+Shift+Backspace 导航到最近编辑区域（差不多就是返回上次编辑的位置）

Alt + F1 查找当前文件或标识

Ctrl+B / Ctrl+Click 跳转到声明

Ctrl + Alt + B 跳转到实现

Ctrl + Shift + I 查看快速定义

Ctrl + Shift + B 跳转到类型声明

Ctrl + U 跳转到父方法、父类

Alt + Up/Down 跳转到上一个、下一个方法

Ctrl + ]/[ 跳转到代码块结束、开始

Ctrl + F12 弹出文件结构

Ctrl + H 类型层次结构

Ctrl + Shift + H 方法层次结构

Ctrl + Alt + H 调用层次结构

F2 / Shift + F2 下一条、前一条高亮的错误

F4 / Ctrl + Enter 编辑资源、查看资源

Alt + Home显示导航条F11 书签开关

Ctrl + Shift + F11 书签助记开关

Ctrl + #[0-9] 跳转到标识的书签

Shift + F11 显示书签

6、搜索相关(Usage Search)

Alt + F7/Ctrl + F7 文件中查询用法

Ctrl + Shift + F7 文件中用法高亮显示

Ctrl + Alt + F7 显示用法

7、重构(Refactoring)

Alt + Delete 安全删除

Shift + F6 重命名文件

Ctrl + F6 更改签名

Ctrl + Alt + N 内联

Ctrl + Alt + M 提取方法

Ctrl + Alt + V 提取属性

Ctrl + Alt + F 提取字段

Ctrl + Alt + C 提取常量

Ctrl + Alt + P 提取参数

8、控制VCS/Local History

Ctrl + K 提交项目

Ctrl + T 更新项目

Alt + Shift + C 查看最近的变化

Alt + BackQuote(') VCS快速弹出

9、模版(Live Templates)

Ctrl + Alt + J 当前行使用模版

Ctrl + J 插入模版

10、基本(General)

Alt + #[0-9] 打开相应的工具窗口

Ctrl + Alt + Y 同步

Ctrl + Shift + F12 最大化编辑开关

Alt + Shift + F 添加到最喜欢

Alt + Shift + I 根据配置检查当前文件

Ctrl + BackQuote(') 快速切换当前计划

Ctrl + Alt + S 打开设置页

Ctrl + Shift + A 查找编辑器里所有的动作

Ctrl + Tab 在窗口间进行切换shelve,xml模块.txt----------------------------------------------------------------------------------------------------
shelve模块：import shelve
shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写；key必须为字符串，而值可以是python所支持的额数据类型。

f.shelve.open(r"shelvel") 目的是将一个在字典放入文本，解释器会创建三个文本。
写入操作：f[key]=“数据”,操作完成后使用f.close()关闭文件。
取出数据:f.get(key)

xml模块：import xml.etree.ElemenTree as ET   (后面的as ET的作用是，使用函数时可以直接用ET.函数名，而不需要每次都打那么长的模块名，也可以不是ET，也可以用其他的变量名)
跟json一样用来做数据交换，json比xml更加简单和高级。
解析xml数据：parse，整体可以这么写tree=ET.parse("xml文件路径")，这个ET.parse其实就相当于open，而tree=ET.parse（"文件路径"）就相当于f=open("文件路径")。
root=tree.getroot()就相当于f_read=f.read()，即把所有的内容读取出来，并以root对象保存，print（root.tag）打印root最外层标签（根节点）的名字，相当于打印f_read的第一行。
为了看到标签里面的内容，可以使用for循环：
for i in root:
    print(i)====此时得到的是第二层级，即最外层的里面一层。
for i in root:
    for j in i:
        print（i.tag, i.attrib, j.tag, j.attrib）====此时打印出i的标签以及属性，还有i下面的子层级j的标签以及属性。（以字典的方式呈现）
socket.txt----------------------------------------------------------------------------------------------------
socket
客户端（client）/服务器（sever）架构---------（c/s架构）
1.硬件c/s架构（打印机）
2.软件c/s架构（web服务）

OSI七层协议：
物理层：光缆，双绞线，无线电波（连接介质）
数据链路层：将首层传来的0，1信号分组，8位一组，一组电信号称为一个数据包，或者一个帧，（为统一分组规范，定了以太网协议Ethernet，Mac地址（标识不同的机器），广播通信，数据链路层只能处理同一个局域网里面的通信，不同局域网就得通过网络层传输数据）
网络层：IP协议（标识不同的子网）（如果想访问其他局域网的计算机，那么就得通过网络层）网关：一个局域网的负责人
传输层：tcp，udp协议
应用层：QQsublime快捷键.txt----------------------------------------------------------------------------------------------------
选择类

Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。
Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。
Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。
Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。
Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。
Ctrl+M 光标移动至括号内结束或开始的位置。
Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。
Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。
Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。
Ctrl+Shift+] 选中代码，按下快捷键，展开代码。
Ctrl+K+0 展开所有折叠代码。
Ctrl+← 向左单位性地移动光标，快速移动光标。
Ctrl+→ 向右单位性地移动光标，快速移动光标。
shift+↑ 向上选中多行。
shift+↓ 向下选中多行。
Shift+← 向左选中文本。
Shift+→ 向右选中文本。
Ctrl+Shift+← 向左单位性地选中文本。
Ctrl+Shift+→ 向右单位性地选中文本。
Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。
Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。
Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。
Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。

编辑类

Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。
Ctrl+Shift+D  复制光标所在整行，插入到下一行。
Tab 向右缩进。
Shift+Tab 向左缩进。
Ctrl+K+K 从光标处开始删除代码至行尾。
Ctrl+Shift+K 删除整行。
Ctrl+/ 注释单行。
Ctrl+Shift+/ 注释多行。
Ctrl+K+U 转换大写。
Ctrl+K+L 转换小写。
Ctrl+Z 撤销。
Ctrl+Y 恢复撤销。
Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。
Ctrl+F2 设置书签
Ctrl+T 左右字母互换。
F6 单词检测拼写



搜索类

Ctrl+F 打开底部搜索框，查找关键字。
Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。
Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。
Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。
Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。
Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。
Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。
Esc 退出光标多行选择，退出搜索框，命令框等。



显示类

Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。
Ctrl+PageDown 向左切换当前窗口的标签页。
Ctrl+PageUp 向右切换当前窗口的标签页。
Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）
Alt+Shift+2 左右分屏-2列
Alt+Shift+3 左右分屏-3列
Alt+Shift+4 左右分屏-4列
Alt+Shift+5 等分4屏
Alt+Shift+8 垂直分屏-2屏
Alt+Shift+9 垂直分屏-3屏
Ctrl+K+B 开启/关闭侧边栏。
F11 全屏模式
Shift+F11 免打扰模式xml模块.txt----------------------------------------------------------------------------------------------------
xml模块：
for i in f.iter("tag名")：
    print(i.tag, i.attrib，i.text)======f.iter("tag")这个函数会将所有的标签名为tag的数据提取出来。然后打印tag，attrib，像<abc>200</abc>这样的数据，就可以用text将200打印出来
给i加属性的方法：i.set("key", "value")，然后执行f.write("文件名")，只有完成了这一步才能真正地将文档的内容进行修改完成。
修改：
for i in root.findall("conutry"):找到所有的country（包括country里面的内容，这就是与iter不同的地方，iter指挥把country那一行找出来，不会把里面的内容也一同带出来）。
找到country后，可以用country.find("rank")将country的子层级rank找出来，然后进行操作。
root.remove(country)将country删除。

创建xml：
import xml.etree.ElementTree as xm
new_xml=xm.Element("namelist")#创建一个根节点，函数会在文本里面创建如下的标签。
#<namelist>
#</namelist>
name=xm.SubElement(new_xml,"name",attrib={"enrolled":"yes"})
#<namelist>
    #<name enrolled="yes"/>
#</namelist>
age=xm.SubElement(name,"age",atttrib={"checked":"no"})
#<namelist>
    #<name enrolled="yes">
        #<age checked="no"/>
    #</name>
#</namelist>
sex=xm.SubElement(name,"sex",attrib={"sex":"man"})
et=xm.ElementTree(new_xml)#生成文档对象
et.write("new_xml.xml")#还可以这样写("文件名",encoding="utf-8",xml_declaration=True)
内置函数.txt----------------------------------------------------------------------------------------------------
内置函数：
abs(-1)取绝对值
all(可迭代对象)，判断可迭代对象是否全是对的，即all函数会判断括号里面对象的每一个元素的布尔值是否是true，空对象、0、None都是false，
当可迭代对象里面的元素都是true时就返回true，否者返回false。
any（可迭代对象）之傲可迭代对象里面有一个true就返回true。
bin(2)把十进制转为二进制，bin（2）==0b10，前面的0b表示二进制。
bool（x）判断x的布尔值。
bytes（“你好”，encoding=”utf-8“）==b'\xe4\xbd\xa0\xe5\xa5\xbd'，把字符串转换为字节形式。即编码。
bytes（“你好”，encoding=”utf-8“）.decode（”utf-8”）==“你好”，把字节转换为字符串形式，即解码。
chr（数字）根据ascall表进行转换，比如chr（97）=a。
与chr相反的是ord，比如ord（a）==97。
dir（函数名），列出函数都可以使用哪些内置方法。
divmod(10，3)==（3，1），函数表示10/3=3取余1，并把结果放在一个tuple里面。
list(enumerate(["a","b"])，2)==[(2，”a“），（3，“b”）函数将对列表（可迭代对象）里面的元素进行编号，编号的起始位置为后面输入的参数，返回值为可迭代对象。
eval（字符串）1.把字符串里面的数据结构（比如说列表、字典）提取出来  2.把字符串里面的运算提取出来并进行运算，比如（“1+2”）==3。

可hash的数据类型即不可变类型，hash是一种算法，hash（“abc”）无论输入的字符串多长，其结果的长度都不变，只要输入的字符串不变，hash值就不变，即输出结果不变。

help（函数）查看函数的详情。

bin(10)十进制转二进制。0b开头。
hex(10)十进制转十六进制。0x开头。
oct(10)十进制转八进制。0o开头。

isinstance(["123"],list)判断["123"]是否为list，即判断前面的参数是否是后面规定的类型。

print（globals（））打印全局变量。
print（locals（））打印当前变量。

max（）找出括号的最大值，可传入数字、列表等，且必须是同类型的数据。如果是字典的话，默认比较key的值，也可以这么做directory.values()比较values的值，directory.keys()比较key的值。

max高级使用：利用max找出列表中的最大元素
aa=[
{"name":"a","age":10},
{"name":"b","age":20},
{"name":"c","age":30}
]
print(max(aa,key=lambda x:x["age"]))

min（）找出括号的最小值。

list（zip（（“a“，”b”），（1，2）））==[("a",1),("b",2)]相当于把传入的两个元组的各个元素（左一个，右一个）放在同一个tuple里面再组成列表。（如果不用list，那么返回一个可迭代对象）
还可以这样用：
a={"a":1,"b":2,"c":3}
y=a.keys()---取出key值。
z=a.values()---取出value值。
c=list(zip(y, z))
print(c)==[('a', 1), ('b', 2), ('c', 3)]
这样做可以把字典里面的key值以及value值取出来组成一个元组，然后组成一个大列表。

pow（x，y）==x**y
pow（x，y，z）==x**y%z

reverse(列表)反转列表元素的顺序。

L="hello"
L[0:2]=="he"
还可以使用slice：
s=slice(0,2)
L[s]=="he"

sorted([1,3,5,7,2,4,6,8])==[1,2,3,4,5,6,7,8]按照大小排序，但只能填入相同类型。
同样，sorted里面也可以填入key函数，即sorted(people,key=lambda x:x["age"])。
aa=[
{"name":"a","age":10},
{"name":"b","age":20},
{"name":"c","age":30}
]
print(sorted(aa,key=lambda x:x["age"]))==[{'name': 'a', 'age': 10}, {'name': 'b', 'age': 20}, {'name': 'c', 'age': 30}]

locals：传回一个字典，里面是自己定义的一些局部变量。
def text():
    msg="哈哈哈"
    print(locals())
text()=={'msg': '哈哈哈'}

globals：
print（globals（））会打印出一个字典，里面包含了系统默认给出的一些变量，以及自己定义的一些全局变量。

vars（）：
如果不传入参数，那么用法跟globals和locals一样，有局部变量时（比如说在定义函数时）打印局部变量（字典），否则打印全局变量。
如果有一个参数（函数名，比如int，help等），那么就会返回一个字典，里面存放着这个函数的所有方法。

注意：这个符号object.__dict__的意思是查看对象的所有方法，并以字典的方式返回。

import 函数，首先将自己写好的函数保存在某个文件里面，导出的时候使用import，比如文件名字叫做“text”，函数的名字叫“hello”，那么导入的时候是import text，使用的时候是text.hello()。
还可以使用__import__(“模块名”)来导入函数，实际上import的调用顺序为import--system--__import__(“模块名”)。
使用__import__的方法为：m=__import__("模块名")，然后m.函数名()。

函数参数.txt----------------------------------------------------------------------------------------------------
参数有形参和实参，形参只有调用时才会占用内存。

位置参数，位置必须一一对应，也就是说当你输入参数的时候第一个位置就是x，第二个位置就是y，第三个位置就是z。
text(x,y,z)

关键字参数，无需一一对应,也就是说x,y,z的位置可以没有顺序，输入te(x=1,z=2,y=3)。

位置参数必须在关键字参数的左边。

def handle(x,type=None):
像上面这个定义函数，第二个参数可以不输入，输入时就表示type=输入的参数，不输入时表示None。

def install(func1=false,func2=true,func3=true)该函数就类似我们安装应用的时候，true表示默认安装，如果不手动改为false，就会执行。

参数组，**字典，*列表
def text(x,*args):
      print（x）
      print（args）
text（1，2，3，4，5，6）==1 \n  （2，3，4，5，6）
后面的参数可以不填，但会打印出括号（）。如果像这样直接是print（args）表示把参数当成一个整体，如果是*args，那么就会把参数的元素拆开来传给函数。

def text(x,**kargs):
      print(x)
      print(kargs)
text(2,z=1,y=2)==2 \n {"z":1,"y":2}
如果kargs前面加个*，即*kargs，输出为2 \n z y 。

当你的函数参数为（x,*args,**kargs），输入参数为（1，2，3，4，5，6，y=1，z=2）时，默认x对应1，*args对应2，3，4，5，6，**kargs对应y=1，z=2 。


切片索引.txt----------------------------------------------------------------------------------------------------
text[0]表示索引text第0个位置的数据。
text[0:1]表示索引范围为【0，1）不包括1。小技巧：1-0=1，用后面的数减去前面的数就表示索引出来的元素的个数。
text[0:-1]索引到最后一个位置，但不包括最后一个元素。text[0:-5]索引到倒数第五个位置，也可以理解为去掉最后五个元素。

len(text)判断出text的长度。

for循环：
text=["csc","csc"]
for x in text:
  print(x)
输出：csc
          csc
text=“cscscs”
for x in text:
  print(x)
输出：cscscs

brake跳出循环：
for x in text:
  break

continue结束本次循环并进入下一次循环：
for x in text:
  continue

range(1,100,5):创建一系列数字,如果后面没有5那么数字是连续的，如果后面填了数字，表示每隔多少个便取一个，5表示每隔5个数取一个数字，即1，6，11，16，21，26。
random:
首先得导入函数，即import random
v2=random.randint(100,1000)表示随机取一个100到1000的数字。

字符串不可修改，一旦修改就会新生成一个字符串列表，元组，字典，运算符.txt----------------------------------------------------------------------------------------------------
运算符
运算符： + - * /
%取余
//取整        9%2=1  9//2=4   实际上取整的数乘以2再加上取余的数就等于9
 
字符串 name=“哈哦耶” 哈哦耶是一个字符串，哈是一个字符，哈哦，哦耶是一个子字符串，注意：哈耶不是一个子字符串，子字符串必须是连续的。
可用以下方法判断某字符或子字符串是否在一个字符串里面：
if “哈哦” in “哈哦耶”：
     print （“ok”）
也可以用 if not in

in，not in 也称为成员操作

列表：list
list=["sdsd"]且可以为u先嵌套，即列表中嵌套列表list=["sdsds","cscscs",["cscs","scsc"],"ppp"]。
且列表集合里面可以放置任何东西。
列表同样可以使用索引以及切片。
列表可以相加，list1+list2
del list[0]删除列表第一个元素。


元组，tuple：
元组中元素不能被修改，不能增加或者删除。
写元组的元素的时候在后边最好加上一个逗号（不会报错），易于区别自己写的是元组。
text=(["122"])，系统把这个认为是列表，如果在后面加个逗号，即text=(["122"],),那么系统会把这个当成是元组。
元组可以使用索引，用法跟list一样。
元组可以转换成列表，列表也可以转换成元组。
元组也可以使用join函数，join会把元组里的元素（不能有列表、数字等，必须是字符串）加起来形成一个字符串。
元组和列表都是有序的。
元组的一级元素不可修改，但二级元素可以被修改，比如元组里面的列表里面的元素，像(122,133,["123"],123)里面的["123"]里面的"123"就可以被修改。
tuple.count("abc")获取元组中某元素的个数。
tuple.index("abc")获取元组中某元素的位置。

字符串str转列表list:
s="sdsd"
s1=list(s)
s1=["s","d","s","d"]

列表也可以使用join函数:
text=['scscs','scsc','www']
v="".join(text)
v=scscsscscwww       type(v)=str
v1="2".join(text)
v1=scscs2scsc2www
（注意join函数只能对列表内的字符串使用，如果列表中包含其他列表或者数字，函数会报错）

text.append("888")函数在列表末尾加入字符串888.（注意，该函数不能这样用v=text.append("888"),这样的话返回的v值为none）
text.extend([123])函数会在列表末尾加入数字123，该函数与append的区别在于，extend传入的必须是可迭代的对象，即字符串、列表等，
且extend是将代入的字符串分割成单个字符，将代入的列表分割成一个个的字符串，而append是整体代入，即你输入什么就代入什么。
text=['scscs','scsc','www']
text.append(["sc"])
text.extend(["csc","999"])
text.extend("123")
print(text)
输出为['scscs', 'scsc', 'www', ['sc'], 'csc', '999'，‘1’，‘2’，‘3’]

locals：传回一个字典，里面是自己定义的一些局部变量。
def text():
    msg="哈哈哈"
    print(locals())
text()=={'msg': '哈哈哈'}

globals：
print（globals（））会打印出一个字典，里面包含了系统默认给出的一些变量，以及自己定义的一些全局变量。

vars（）：
如果不传入参数，那么用法跟globals和locals一样，有局部变量时（比如说在定义函数时）打印局部变量（字典），否则打印全局变量。
如果有一个参数（函数名，比如int，help等），那么就会返回一个字典，里面存放着这个函数的所有方法。

注意：这个符号object.__dict__的意思是查看对象的所有方法，并以字典的方式返回。

text.clear()函数会清空列表中的所有元素。

text3=text2.copy()函数将复制text2到text3中（尝试过直接使用text3=text也可以执行这个功能，但还不清楚其他功能是否会发生变化，该函数也称为浅拷贝）

text.count("22")该函数跟str.count("22")类似，即计算列表中有多少个"22"。

text.index("ss",0,1)该函数索引出字符串"ss"的位置，后面两个参数可不填，表示的是索引的起始和终止位置。

text.insert(8,"66")该函数在列表的第8个位置插入内容"66"。（加入列表有十二个元素，你插入的位置为15，那么将在列表的最后一个位置插入内容）

text.pop(0)删除列表中第0个位置的元素。
该函数还可以这么用：
v=text.pop(0)
执行上述操作后，不但text.pop(0)执行了，还可以获取到被删除的值，即text[0]，并且存储在v中。

text.remove("ss")删除掉字符串中的"ss"，且默认从左边开始，删除第一个"ss"。
也可以使用del text[1]的方法来删除列表中的元素。

text.reverse()函数将列表中的所有元素的位置反转，例如最后一个位置的元素提到最前面，第二个位置的元素调到倒数第二个位置。

text.sort()将列表中的字符串进行从小打到大的排序，如果列表中同时出现字符串和数字，那么会报错，因为无法比较大小。在括号（）内填入
reverse=True将会反转排序，即从大到小排序。

字典的创建：xxx={“abc”：“123”，“ccc”：“234”}，里面有两个键值对。（key是abc，value是123）
字典里的value可以是任何值，像这样info={"k1":18,"k2":"abc","k3":True,"k4":(123),"k5":["ppp"]}
字典是无序的，元组和列表是有序的。因此字典不能用info[0]来索引出元素。
字典索引元素的方法为info["key"]。
字典的key值不能是列表。
del info[key]删除字典里面的key以及key对应的元素。

字典也可以使用for循环
for x in info:
    print(x)
输出为字典info里面所有的key
当我们想要输出字典里面的value时
for x in info.values():
    print(x)
输出即为字典info里面的value值。
当然也可以用for x in info.keys():，输出为字典里面所有的key值。
如果想同时输出key和value，可以这么做for x in info.keys():
                                                              print(x,info[x])
当然也可以用python自带的函数这么写：
for v,k in info.items()
    print(v,k)

也可以这么创建字典：
v=dict.fromkeys(iterable，value)，前面的参数填上可迭代的对象，后面的参数填值。


v=directory.pop("key")函数将删除directory里面的key以及key对应的value，且将删除的值（value）存储在v中。
v=directory.pop("key",100)函数将删除directory里面的key以及对应的value，如果directory里面没有”key“，那么存储的值为100，如果
directory里面有”key“，那么存储的值为key对应的value值。
v=directory.popitem()函数将自动随机删除directory里面的一个值（实际上，实验了这么多次，发现删除的都是字典最后一个值，即我们输入
directory里面的最后一个值。）。
v=directory.setdefault(key,value)函数将在directory里面加入一对key：value，返回的v值为value，但如果key存在，那么就不会添加，返回
的v值为原先存在的key对应的value值。
directory.update({"a":123,"b":456})函数将根据传入的参数（字典）进行更新，如果传入的字典里面有directory里面没有的，那么就会给
directory加进去，如果存在有相同key，那么会根据新的value值对directory进行更新。

directory.keys()可以把key值组成一个列表。
























字符串.txt----------------------------------------------------------------------------------------------------
a.title(),字符串a里面所有的单词首字母大写，其余字母小写

a.capitalize(),字符串里第一个字母大写，其余小写，如果第一个字符不是字母，那么函数只会让后面所有的字母小写。

a.lower()与a.casefold()都是用来将字符串里面的所有大写改为小写，但前者只能改变英语的大小写，而后者功能更强大，
可以改变除英语外（比如法语）的字母大小写。
a.upper()与a.lower()功能相似。

a.swapcase()将字符串内的大小写转换，大写变小写，小写变大写。

a.count("a",0,5)计算字符串a里面有多少个“a”，也可以输入“ab”看里面有多少个"ab"，后面的0表示从字符串的第0个
位置开始找（包括0），一直到第5个位置结束（不包括5）。(0和5可不输入）

a.startswith("a",0,5)如果字符串在第0到第5的位置上是以"a"为开头的，那么返回true，否者返回false。(0和5可不输入）
a.endswith("a",0,5)如果字符串在第0到第5的位置上是以"a"为结尾的，那么返回true，否者返回false。(0和5可不输入）

a.find("a",0,5)在0和5之间查找字符"a"，默认找到第一个"a"。（可不输入0和5）

上述0和5所表示的区间为[0,5)。

a.format()
text="I am a good {aa}, age {bb}."
v=text.format(aa="boy", bb="18")
v=I am a good boy, age 18.
该函数做的事称为格式化，即将字符串中的占位符（本例为{aa}）替换为所想要的字符或字符串。
good=19
aa="I am a good {0}, age {2}."
bb=aa.format("boy",good,18,89)
bb=I am a good boy, age 18.
当占位符中的字符为数字时，可直接在（）内输入想要的字符串，然后函数会根据占位符中的数字自动对应（）内的内容并赋值。
也可以在format里面加入字典，但注意要在前面加入**，像这样format（**{"a":"a","ab":"ab"}）。
（format的更多用法，可看视频第02部分，day14，07）
a.format_map()
用法跟format差不多，但format_map的（）内写入的是字典，例如format_map（{"aa":"abc","bb":"abc"}）。

index的功能与find差不多，只是find找不到时返回-1，而index直接报错，工程中多用find。

a.isalnum()判断字符串a里面是否仅是数字或字母，如果有其他字符将返回false，否则返回true。
a.isalpha()判断字符串是否仅是字母（有数字也返回false，与isalnum不同）。
a.isdigit()判断字符串是否仅是数字。
a.isdecimal()判断字符串是否仅是数字（仅可判断十进制数字）
（上面的isdigit可以判断出更多类型的数据，比如②，而isdecimal不能判断②，即会输出false）
a.isnumeric()比上面两个都厉害，连中文的”二“也能判断出来。
（工程中用的比较多的还是isdecimal，因为它仅可以判断十进制的数字）

a.isidentifier()判断字符串是否为可用变量名（可用变量名必须是由字母、数字和下划线组成，且开头必须是字母或下划线）

a.isprintable()判断字符串中是否有不可显示的字符（比如\t、\n，在打印出来之后看不到”\t“、”\n“），没有的话返回true，否则返回false。

a.isspace()判断字符串中是否全部是空格，是的话返回true，否则返回false。（当字符串中一个字符也没有的时候，返回false）

a.istitle()判断字符串中每个单词是否都是大写开头，是的话返回true，否则返回false。

a.islower()判断字符串是否都是小写，是的话返回true，不是的话返回false。
a.isupper()与上述函数功能相似。

isinstance(["123"],list)判断["123"]是否为list，即判断前面的参数是否是后面规定的类型。

"____".join(text）在字符串text的每个字符之间加入双引号内的内容（比如text=“sdsd”,"2".join(text)="s2d2s2d2"。

a.center(20,"*")把字符串居中显示，比如说字符串总长为6，那么字符串前面和后面都会有7个*，*******123*******，
如果前面的范围（比如说20）小于字符串的长度，那么输出内容不改变，如果是单数，那么字符串前的*会比字符串后的*多一个。
a.ljust(50,"b")在字符串的右边填充字符"b",字符串总长度为50，如果字符串的长度大于50，那么输出为原字符串，并不会填充"b"。
a.rjust(50,"b")在字符串的左边填充字符"b",字符串总长度为50，如果字符串的长度大于50，那么输出为原字符串，并不会填充"b"。
（注意：上述两个函数都只能填充单个字符）
a.zfill(50)在字符串的左边填充字符”0“，字符串总长度为50。（一般很少用这个函数，因为上述函数已经完全可以实现这个功能）

a.lstrip()删除字符串左边的空格,\t,\n。当（）内有内容时，默认只删除括号内的内容，且不管顺序，例如（”asd“），a=adsa  sdds, 输出为sdds，
前面的adsa已被删除，要是内容为（" asd"），那么整个字符串都会被删除掉。
a.rstrip()删除字符串右边的空格,\t,\n。
a.strip()删除字符串左右两边的空格,\t,\n。

翻译，加密解密
str.maketrans(text,text2)，translate
text="abcdefg"
text2="1234567"
text3="bbbbbb"
m=str.maketrans(text,text2)
v=text3.translate(m)="222222"

a.partition("c")该函数用于分割字符串，分隔符为"c"
a="abcdce"
a.partition("c")=('ab', 'c' ,'dce')
a.rpartition()默认从右往左进行分割，而partition默认从左往右进行分割。
（注意：该函数只能找到第一个c进行分割，也就是只能分割成3份，如果c在第一个位置，那么会分割成（"","c","xx")）

a.split("c",2),该函数作用与partition相似，只是split会分割所有的分隔符，且分割之后分隔符会消失。后面的2表示分割两次，形成三个子集。
默认从左到右进行分割。
a.rsplit()默认从右往左进行分割。
分隔符在第一个位置出现:
text="cacscdc"
v=text.split("c")
v=["","a","s","d",""]
a.splitlines(x),该函数只能根据换行符来进行分割，括号内的x为true或者false，默认为false（即不输入内容），当true时返回的子集会带有换行符，
而false时不带有换行符。
text="cacb\ncdc\necfcg"
v1=text.splitlines(True)
print(v1)=['cacb\n', 'cdc\n', 'ecfcg']

a.expandtabs(8)函数在字符串中找到\t，比如“aaaa\taaaa",前面有四个a，那么\t占4个空格（即前面的字符加上空格一共占用8个位置），输出为aaaa    aaaa。

a.replace("abc","nn",5)该函数表示将字符串a里面前5个"abc"替换成"nn"，如果不填后面的数字，那么默认替换全部的“abc”。


封装，getattr，动态导入模块.txt----------------------------------------------------------------------------------------------------
封装：
第一层面：类的本身就是一种封装。第二层面：在类的内部定义私有的，外部无法访问的。第三层面：明确区分内外，内部实现的逻辑，外部无法知晓。
明确地区分内部和外部，内部指的是class内部，外部指的是外部调用。
在class内部定义的函数的函数名（数据属性也可以）前面加上__，例如__star，那么在外部调用的时候不能使用 实例.__star去调用，而是要用 实例._类__star去调用，相当于给函数换了名字。

反射：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
hasattr(object，name)判断object中有没有一个name字符串对应的方法或属性（也就是object能不能调用得到name对应的方法或者属性，注意name为字符串）。返回值True or False。
getattr(object，name，“找不到的时候返回这个字符串”)返回name对应的方法或者属性，如果是方法的话，可以在返回值后面加（）来执行这个函数。第三个参数的意思是如果找不到的话，会返回后面的字符出。
setattr(object，"字符串或者函数"，值)给object对象设置属性，相当于object.key=value（就是给实例增加属性）。
delattr(object，"字符串")删除属性。
（以上方法同样适用于类）

动态导入模块：
abc=__import__("模块名")，但是注意，如果模块外面有很多层文件，那么，想调用最里面那层文件，要这样做，m1.m2.m3.m4.m5。
from abc import *导入模块abc所有的内容。

调用len(str)实际上是在调用str.__len__()

面向对象进阶：
在class内定义一个__getattr__(self,item)，在该class实例化之后，实例调用class里面的属性或者函数，如果函数存在，则正常运行，如果函数或者属性不存在，那么该__getattr__函数就会执行。
在class内定义一个__delattr__(self,item)，在进行del或者delattr操作时会执行该函数。
在class内定义一个__setattr__(self,key,value)，实例在进行设置或者__setattr__操作时便会执行该函数，key是设置的变量，value是赋予的值。
注意，在给实例增加属性的时候，例如f1.abc="abc"，在实例的属性字典里面是找不到abc的，所以，要这么操作：f1.__dict__["abc"]="abc"，直接操作属性字典就可以了。（给实例加属性后，实例的属性字典找不到增加的内容怎么办？）

授权：授权是包装的一个特性，包装一个类型通常是对已存在的类型的一些定制，这种方法可以新建、修改或删除原有产品的功能。其他原则保持原样，授权的过程，即是所有更新的功能都是由新类的某部分来处理，但已存在的功能就授权给对象的默认属性。实现授权的关键点就是覆盖__getattr__方法。

__getitem__:执行obj[属性]（即调用函数或者属性时）触发
__setitem__:执行obj[属性]=属性值时触发
__delitem__:执行del obj[属性]时触发

__get__,__set__,__delete__触发条件：
class 描述符：
    def __get__():
        pass
    def __set__():
        pass
    def __delete__():
        pass
class 类：
    name=描述符（）
obj=类（）
obj.name  ==== 触发get
obj.name="abc"  ====触发set
del obj.name  ====触发delete

__del__：析构方法（垃圾回收时触发）

__getattribute__:只要调用属性或函数就会触发，不管存不存在。（当该函数抛出错误时，__getattr__才会触发）

局部、全局变量.txt----------------------------------------------------------------------------------------------------
全局变量，局部变量：
在函数内部定义的变量即为局部变量，在函数外部定义的变量为全局变量。
如果全局变量和局部变量使用了同一个名字，即函数内部定义了一个变量与全局变量同名了，那么在函数内部局部变量优先。

如果想在函数内部修改全局变量可以这么做：
在函数内部加入一行 （global + 变量名）

风湿理论：函数即变量
布尔值，运算符.txt----------------------------------------------------------------------------------------------------
布尔值： True  False

name="nizaiganma"
v="nz" not in name
print(v)――――――True

！=不等于    ，   <>不等于  （一般用！=）
逻辑运算符用 and 和 or（and的优先级大于or）

算术运算符：
**表示多少次方，比如10**2=100

count=count + 1--------简写 count += 1

比较运算、逻辑运算、成员运算得到的是一个布尔值，即 True 或 False
而算术运算和赋值运算得到的是一个真实的值

bool()在括号（）里面填入None,"",{},[],(),0都会返回false，输入1,"abc"等就会返回true。异常处理.txt----------------------------------------------------------------------------------------------------
错误分为语法错误和逻辑错误。
语法错误：print("hello"---少了括号，if a---少了冒号，就是不按照规定去写代码。
逻辑错误：像res=1/0，          还有aa=[1,2]，aa[10]，本身不存第10个元素，这就是逻辑错误。
异常就是程序运行时发生错误的信号。


异常信息：由三部分组成
Traceback===》追踪信息--exc_tb
NameError===》异常类--exc_type
NameError：信息===》异常值--exc_val


AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x

IOError 输入/输出异常；基本上是无法打开文件
ImportError 无法引入模块或包；基本上是路径问题或名称错误

IndentationError 语法错误（的子类） ；代码没有正确对齐
IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]

KeyError 试图访问字典里不存在的键
KeyboardInterrupt Ctrl+C被按下

NameError 使用一个还未被赋予对象的变量

SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）

TypeError 传入对象类型与要求的不符合

UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，
导致你以为正在访问它

ValueError 传入一个调用者不期望的值，即使值的类型是正确的

语法上的错误与异常处理无关，必须在程序运行前就修正。

处理异常：即代码执行到有错误的地方时，整体代码继续运转，不会停止。
try:
    被检测代码（即有可能出错的代码）
except ValueError（可以是其他错误信息，也可以不写） as e： （as e的目的是方便下面直接提取错误信息ValueError）
    print(e)
该代码表示，如果被检测代码出现错误，会捕捉到错误信息并且打印出来，且下面的代码正常执行。但是检测到错误时，try里面、发生错误代码下面的代码不会执行，且立刻跳到except这一步。
也可以这么写：
try:
    被检测代码
except ValueError as e:
    print(e)
except KeyError as e:
    print(e)
异常类只能用来处理指定的异常信息，如果上面只有ValueError，而发生的是KeyError的错误，那么程序就会报错。
当然有个可以捕捉任何异常的类，叫Exception，except Exception------可以捕捉任何异常。（万能异常）

异常处理常用while循环来辅助：
while True:
    try:
        age=input()
        int(age)
        break
    except Exception as e:
        print("请重新输入")
当被检测代码发生错误时或直接跳转到except那一步，然后继续循环，直到输入正确，这时候break就会执行跳出循环。
还可以在try、except下面加入下面两个代码：
else:
    print("没有异常时执行")
finally:
    print("有无异常都要执行，通常是进行清理工作")

断言 assert：
print("===")
assert 1==2
print("===")
==>运行结果是===，断言的内容一旦不成立，后面的代码将不会执行，且会抛出错误AssertionError。
接口继承.txt----------------------------------------------------------------------------------------------------
接口继承：规定子类必须拥有父类的方法。父类只定义了函数，但不具体写上函数的内容，当子类继承这个函数后必须对函数进行具体化才能有效果。
但要是子类不去定义这个函数的话，继承就没有效果，这时候继承跟不继承都没啥区别。而且只是你想着子类必须去具体化父类的方法，实际上子类并没有被限制到，它可以不去具体化这个函数。

如果我想要子类在继承父类之后必须具体化函数（具体化不一定是要写上具体执行的方法，可以用pass带过，这样做的目的是让子类知道你应该重新去写这个函数，但什么时候写没关系）

import abc
class All_file(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def 函数
    @abc.abstractmethod
    def 函数
如果子类继承了这个父类All_file，那么子类就必须在自己的内部重新写上一遍@abc.abstractmethod下面的这个函数，否者，子类在实例化的时候就会报错。
文件操作.txt----------------------------------------------------------------------------------------------------
文件处理流程：（路径，“r，w，r+，a”，encoding=“gbk，utf-8”）
文件的读模式：r
1.f=open(路径，记得写上文件的后缀名，比如文档的.txt),f称为文件句柄。如果在括号里面填入“r，w，a”就会有不同的功能，
比如（路径，“r”）表示只读，w表示只写，a表示读写。
2.date=f.read（）
3.print(date)
4.f.close()

f.readable()判断文件是否可读。True or false。
f.readline()只读一行，且下一次运行readline时会直接读下一行，即不会两次读取同一行。
f.readlines()读出来的是一个列表。
如果readline之前使用了read，那么readline将不起作用，因为read已经把全部文件都读取出来了，即文件的光标移动到了最后一个位置。

文件的写模式：w
注意在此模式下，如果文件不存在，那么系统会新建一个文件，如果文件存在，那么文件就会被清空然后开始写操作。
1.f=open(路径，“w”)
2.f.write(“内容”)注意：要自己添加换行符\n，文本不会进行换行操作。
3.f.close()

open每次打开文件都要使用close来关闭，而with则不用使用close关闭，系统会自动关闭。
with open（路径，“r,w,a,x”）as f：
	f.write("love you")
with还可以同时打开多个文件：
with open（路径，“r,w,a,x”）as f，open（路径2，“r,w,a,x”）as f2：
当感觉一行太长的时候，可以在第二个open前面加一条\然后进行换行。

f.writable()判断文本是否可写。
f.writelines(列表)，比如["哦","哈"]注意：无论是写文本还是传入列表，都只能是字符串类型，数字都不行，必须是字符串。

x模式：
与w相似的是x，只写模式，不存在文件则创建文件，存在文件则报错。

文件的追加模式：a
不可读，文件不存在就新建文件，文件存在就追加内容，不会清空内容。

文件的r+模式，可读，可写（追加）。文件必须存在，即不会新建文件。


总结：
r只读，r+可读写，文件必须存在。
w只写，w+可读写，文件存在则清空再写，不存在则创建。
a只写，a+可读写，文件存在则追加内容，不存在则创建。
x只写，x+可读写，不存在则创建，存在则报错。

windows中\r\n表示换行，linux中\n表示换行。

二进制与字符串互转：
“字符串”------encode------bytes
bytes------decode------“字符串”
bytes（x，encoding=“utf-8”）x为字符串，将x编码为字节形式。
x.encoding("utf-8")将x编码成字节形式。

f.closed判断f是否关闭，是的话返回true，否则返回false。closed后面没有括号（）。
f.encoding判断打开文件f的编码，前提是使用open函数时，括号里面必须输入encoding=“utf-8”。

f.flush()刷新，比如你在内存操作，但没有保存到硬盘，使用这个函数可以进行保存（刷新操作）。

f.tell()返回光标所在位置，光标的移动单位为字节。

在windows平台中换行为\r\n，但是在使用python时，它会自动把所用的换行符都读为\n，如果想让读出来的结果更准确，可以这么做：
open（路径，“r”，encoding=“”，newline=“”）关键在于最后一个参数，它会让python不转换换行符，也就是保持原来的\r\n。

f.seek(6)控制光标的移动，6表示光标目前在第六个字节的位置。f.seek(6,0或1)第二个参数填入0或者1，0表示默认从第0个位置开始数，1表示从当前光标的位置开始数，当选择1时，open函数里面必须使用“rb”（“ab”也行），即以二进制格式打开文件。
f.seek(-5，2)光标从后面开始读取，即反向读取，前面是负数的话，后面必须填2，同样，open函数里面必须加上b。

f.read(5)读取5个字符，注意，是字符不是字节。

f.truncate(10)截取文件的前十个字节，即保留前十个字节，后面的内容会被删除。










模块.txt----------------------------------------------------------------------------------------------------
模块：
如果使用 import abc来导入模块，那么使用函数时每次都需要输入abc.efg，为方便可以直接导入efg函数，from abc import efg，这样就可以直接使用efg了。
模块（time，random）.txt----------------------------------------------------------------------------------------------------
模块：如果模块有多个包层级，可以这样导入
from a.b.c.d import f

if __name__=="__main__":   该代码的作用是使本if语句下面的函数只能在本py文件下面执行，也就是说，如果该文件被调用了，if语句下面的函数也不会被执行。
原因是，在本文件中（即if语句的文件），__name__=="main"，而在调用本文件的其他文件里，__name__==路径（被调用文件的路径）。

time模块：
time.time()记录1970年0时0分到该函数执行完成的时间，用秒来记录。
time.localtime()当地时间。可通过.tm_year来获取年份，具体可先打印出localtime然后根据显示的内容调出你需要的时间。
localtime(123456)还可以在括号里面填入参数，本例计算的是距1970年123456秒的时间。
time.gmtime()世界标准时间，格林尼治时间。

time.mktime(结构化时间)将结构化时间转换为时间戳。
结构化时间就是像localtime这样的一系列时间，而时间戳就是像time.time()这样的秒数。

time.strftime("%Y-%m-%d %X"，time.localtime())将结构化时间转化为字符串时间，%Y表示年，%m表示月，%d表示日。
time.strptime("x:y:z","%Y:%m:%d")将字符串时间转换为结构化时间。

time.asctime()当地时间，这个函数看时间比较方便，不是结构化时间。-------格式：Wed Dec 11 16:05:42 2019
time.ctime()

datetime模块：
datetime.datetime.now()-------格式：2019-12-11 16:05:42.179680


random模块：
random.random()随机出现一个(0,1)浮点数。
random.randint(x,y)随机选取一个范围在[x,y]的整数。
random.randrange(x,y)随机选取一个范围在[x,y)的数。
random.choice([x,y,z])随机选取一个列表里面的值。
random.sample([x,y,z],h)在列表里面选取h个值然后组成一个新的列表返回。
random.uniform(x,y)随机选取一个在[x,y]范围内的浮点数。
random.shuffle([x,y,z])将列表的元素顺序打乱。
正则表达式.txt----------------------------------------------------------------------------------------------------
正则表达式re:    正则就是模糊匹配
元字符：. ^ $ * + ? {} [] | () \

. 通配符，任何字符都能匹配得上（除了换行符即\n）
例如re.findall（“a..x”，“abbxaaabbbcccabsx”）==["abbx","absx"]一个点代表字符（任意字符）。

^尖角号，只匹配字符串开头。（尖角号只能放在规则开头，例如“^a..x”）。

$dollar符，只匹配字符串结尾。（dollar符只能放在规则结尾，例如“a..x$”）。

重复符号：*，像规则a*，匹配任意数量的a。范围（0，正无穷）。
	+，类似于*。范围（1，正无穷），+与*的区别是，a+规则匹配时字符串必须要有一个a，而a*匹配时字符串里不一定要有a。
	（贪婪匹配，尽可能多地匹配）
?，如a..x?，可以匹配a..，a..x，也就是x可要可不要，即?前面的x的数量为（0，1）。
在*或者+后面再加个？可以把贪婪匹配变成惰性匹配，即尽可能少地匹配。

{}，z {x，y}匹配x――y个z，不填y表示x――正无穷。如果只写y，像z{8}，那么只能匹配8个z。

[]，x[yz]可以匹配xy，xz，不能匹配单独的x，或者单独的y，z，也不能匹配xyz。[a-z]表示字符"a"--"z"。当然也可以这样来表示0--9：[0-9]。
注意：在[]里面加入^表示“非”，例如q[^a-z]，那么只能匹配  q+非(a-z)的字符，例如q1，q2，q3，而qa，qb，qc是不能够匹配的。
编程实例：找到最里面的括号所包含的内容re.findall("\([^()]*\)","((scscs(2-1)))")==["(2-1)"]。

()，优先匹配，例如：re.findall("www.(abc),com","www.abc.com")==["abc"]，在括号里面这样写可以取消优先级(?:abc)==["www.abc.com"]
（abc|123）优先匹配abc或者123，[abc|123]与[abc123]的意义一样。
问题（已解决）："(abc)+","abcabc"==["abc"]，为什么不是["abcabc"]呢，原因就在于()的优先级，它会在匹配成功后输出()里面的内容，而不是把匹配成功的内容全部输出，这时候就可以通过取消优先级来输出全部内容"(?:abc)+","abcabc"==["abcabc"]。

\d匹配任何十进制数字，相当于[0,9]。
\D匹配任何非数字字符，相当于[^0,9]。
\s匹配任何空白字符，相当于[\t\n\r\f\v]。
\S匹配任何非空白字符。
\w匹配任何字母数字字符，相当于[a-zA-Z0-9]。
\W匹配任何非字母数字字符。
\b匹配一个特殊字符边界，比如空格，&，#。比如我想匹配出字符串“hello i am”里面的i，可以使用规则r“\bi\b”，加上r的原因是:\b在python解释器有其独立的意义，当解释器交给re模块的时候，re收到的不再是\b，所以加上r是为了让python解释器不做任何转义，即\b就是re所需要的\b。
(也可以用\\\\来表示一个普通的\，在python解释器中四个特殊的\转为两个普通的\\，然后传到re中，re将两个特殊的\\（当普通的\\来到re时就变成特殊的了）转为一个普通的\)
|或匹配，例如ka | b，匹配ka或者b。

分组：“（?P<name>规则）”，例如一个字符串“alex20”，我想提取alex和20，并且给这两个信息分组，就可以这么做“(?P<name>[a-z]+)(?P<age>\d+)”。获取分组内容的方法：函数.group("name","age")。

re.findall(匹配规则，字符串)返回满足匹配条件的结果，以列表形式呈现。
re.search(匹配规则，字符串)只要找到一个满足条件的就返回结果（返回一个对象），可以使用.group()方法得到匹配的字符串。如果前面有分组的话，在group的括号里面填入“name”，就可以得到name对应的内容。
re.match(匹配规则，字符串)从字符串开头开始匹配，满足要求返回一个对象，可以利用.group()来得到匹配成功的字符串。（这个函数的特点就是从字符串开头开始匹配，遇到第一个满足条件的就直接返回一个对象，所以用search也同样可以完成上述功能，比如^加匹配规则就是从头开始匹配，search遇到第一个满足条件的就直接返回一个对象，两者都可以用.group()来获取满足条件的字符串）
re.split( [ 匹配规则 ] ，字符串)与python自带的split差不多，比如我想通过空格和|来分割字符串“hello abc|bcd”，就可以这么写“[ |]”,"hello abc|bcd"。
re.sub(匹配规则，替换字符串，原字符串)字符串替换，比如我想把字符串“123abc123”里面的123替换成A，可以这样写（“\d+”,"A","123abc123")==AabcA。（注意：还可以加入第四个参数，第四个参数为数字，意思是替换的次数，不写的话表示满足匹配规则的字符将全部被替换）
(上面的sub返回的是一个字符串，如果使用re.subn，返回的是一个元组tuple)

re.compile("规则")自定义函数功能，多次调用时，不必每次都输入多个参数，例如：
com=re.compile("\d+")自定义规则
com.findall("123abc123")==["123","123"]
(其实就是先定下一个规则，后面调用的时候就不必那么麻烦再次打入规则)

re.finditer(匹配规则，字符串)功能与findall一样，只不过finditer返回的是一个迭代器，需要用next()来获取数据，注意：这个时候需要这样写，next().group()，才能获取到我们想要的字符串数据。
整体可以这样写：
ret=re.finditer(规则，字符串)
next(ret).group()==数据



类.txt----------------------------------------------------------------------------------------------------
类：把一类事物的相同的特征和动作整合到一起就是类，类是一个抽象的概念。
对象：就是基于类而创建的一个具体的事物（具体存在的），也是特征和动作整合到一起。
例如：
def school(name,addr,type):
    def kao_shi(school):
        print("%s学校正在考试"%school["name"])
    def zhao_sheng(school):
        print("%s %s正在招生"%(school["type"],school["name"]))
    def init(name,addr,type):
        sch={"name":name,
                "addr":addr,
                "type":type,
                "kao_shi":kao_shi,
                "zhao_sheng":zhao_sheng}
        return sch
    return init(name,addr,type)
定义类的时候，类名要首字母大写。
调用类的方法和属性，实际上时在调用类的属性字典，即调用 Lei.__dict__====(这是个字典，里面有属性，有函数，可以用__dict__["方法名称"]来调用)。

类的属性：
class.__name__类名。
class.__doc__相当于注释，比如在类的开头打上一段字符串"这是个类"，那么通过这个函数__doc__就可以打印出这句话。
class.__bases__类的共同祖先，一般是object。
class.__dict__类的字典。

class aa：
 def __init__(name,age,gender):========一旦实例化就会执行，比如你下面的代码中有一行print()，那么执行bb=aa()的时候，函数会执行print。
    self.name=name
    self.age=age
    self.gender=gender
在class里面定义一个__init__相当于创建查看了一个默认字典。创建实例调用时可以直接这样写: aa.name。也可以用aa.函数名（）来调用函数。
类属性的增删改查：
1.查看类属性：class.属性名
2.修改属性：class.属性名="新属性名"
3.增加属性：class.定义属性名=“属性内容”
4.删除属性：del class.属性名7 
实例属性的增删改查：
1.查看属性字典：class.__dict__
2.增加属性：class.属性名="属性内容"
3.实例只有数据属性，所以不能增加函数属性，实例调用的函数是类的函数属性，可以通过给类增加函数属性来达到给实例增加函数属性的目的。
4.（其实可以强行给实例增加函数，但一般不这么干）
5.修改：example.age=18， 注意：不要修改底层的属性字典，像这样example.__dict__["age"]=18
6.删除:del example.age


@property
def abc(self):
在实例调用该函数时，不需要在函数名后面写上（）便可以直接运行函数，且类不能调用该函数（不报错，但不显示）。与实例绑定。

@classmethod
def abc(cls):      ========括号里面的cls类似于self，表示该方法用于给类调用。与类绑定。

@staticmethod
类的工具包，不与实例或者类绑定。
在def abc(a,b,c)的括号里面不需要填入self，该函数可以被类和实例调用。

组合：
大类里面方小类

面向对象编程的三大特性：
继承，多态，封装

类的继承：
class abc(父类1)：===单继承    abc(父类1，父类2)：===多继承
子类可以调用父类的方法和属性。

如果同时定义了几个类，他们有共同的特点，比如跑步，吃饭等，那么就可以把他们的相同点提取出来做成一个新的类，在需要这些方法的时候直接继承这个类就可以了。



接口继承：
规定子类必须拥有父类的方法。父类只定义了函数，但不具体写上函数的内容，当子类继承这个函数后必须对函数进行具体化才能有效果。
（接口是指基类（接口类）里面定义的函数）
但要是子类不去定义这个函数的话，继承就没有效果，这时候继承跟不继承都没啥区别。而且只是你想着子类必须去具体化父类的方法，实际上子类并没有被限制到，它可以不去具体化这个函数。

如果我想要子类在继承父类之后必须具体化函数（具体化不一定是要写上具体执行的方法，可以用pass带过，这样做的目的是让子类知道你应该重新去写这个函数，但什么时候写没关系）

import abc
class All_file(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def 函数
    @abc.abstractmethod
    def 函数
如果子类继承了这个父类All_file，那么子类就必须在自己的内部重新写上一遍@abc.abstractmethod下面的这个函数，否者，子类在实例化的时候就会报错。


类的继承顺序：
新式类（继承object的类，其子级也是新式类）：
(python3默认所有的类都是新式类)
              ------D------F
   ------B
A                                           在左边这个继承顺序中，A是最大的父级，F是最小的子级，继承顺序为F->D->B->E->C->A.（广度优先）
   ------C
              ------E------F
经典类（不继承object的类，其子级也是经典类）：A是最大的父级，F是最小的子级，继承顺序为F->D->B->A->E->C.（深度优先）

上下文管理协议：
在类Open里面定义了__enter__()，__exit__()
with Open() as f:
    print("1230")
那么在with这一行就会触发__enter__()，然后执行print，当with内部的函数执行完成后就会触发__exit__()。
（注意，此时的f是个空对象，它没有任何赋值，那怎么办呢？你需要在def __enter__()下面创建一个返回值，return self，相当于把实例self赋予给了f，此时的f就是Open的一个实例）
（with函数还可以直接使用且不用赋值给f，即可以直接这样使用：with Open（）：    ）
（__exit__(self,exc_type,exc_val,exc_tb)括号里面的后三个参数是获取错误信息的，如果在执行with的过程中出现了错误，就可以在__exit__()的后面添加return=True，这样就可利用print(exc_type来打印出错误信息了)）
（异常也会触发__exit__的运行，且它会把异常吃掉，从而不至于使得后面的代码因异常而无法执行）

系统dos命令.txt----------------------------------------------------------------------------------------------------
cd   change directory 改变当前目录
cd ..返回上一级目录
cd .当前目录

md   创建目录
rd     删除空目录
rd/s  删除目录（包括空目录）

dir    列出当前目录的所有子目录装饰器.txt----------------------------------------------------------------------------------------------------
装饰器：本质就是函数，功能是为其他函数添加附加功能。高阶函数+函数嵌套+闭包。
原则：
1.不修改被修饰函数的源代码
2.不修改被修饰函数的调用方法

高阶函数：
1.函数接收的参数是一个函数名
2.函数返回的是一个函数名
（满足上述条件的任意一个就是高阶函数）

下面的代码将展示装饰器如何使用：@timmer
import time
def timmer(func):
	def wrappper():
		print(func)
		func()
	return wrappper

@timmer
def test():
	time.sleep(3)
	print("test函数运行完毕")
test()===<function test at 0x0000018F25AD7B70>  test函数运行完毕

上面@timmer这步操作实际上的意思就是进行test=timmer(test)
这就是装饰器的使用，即在不改变源代码和调用方式（都是使用test这个函数名去调用）的前提下给函数增加新的功能。

（*args，**kwargs）表示可传入任何类型、任意数量的参数。
用法（1，2，3，4，5，6，name=“alex”），print（args，kwrgs）==（1，2，3，4，5，6），{“name”：“alex”}。
也就是说当打印的时候不带*，那么函数会自动将参数转为元组和字典再输出，如果打印的时候带*，传入的第二个参数必须是字典，第一个参数可以是元组也可以是其他。
上面的（1，2，3，4，5，6，name=“alex”）也可以这样写（*（1，2，3，4，5，6），**{“name”=“alex”}）。

要补回来的课程.txt----------------------------------------------------------------------------------------------------
day13学生作业没做
day15的03、04没看解压序列.txt----------------------------------------------------------------------------------------------------
解压序列，a,b,c=(1,2,3)，即a=1，b=2，c=3。必须一一对应，多一个少一个都不行。
如果序列太长了，可以这么做，a，*x，c=（1，2，3，4，5，6，7，8，9），a=1，x=[2，3，4，5，6，7，8]，c=9。

进制转换.txt----------------------------------------------------------------------------------------------------
type(abc)，用这个函数可以查到abc是什么类型的数据

num=“0011”
c=int（num，base=2）
c=3  （base=10,  c=11;  base=8,  c=9;  base=16,  c=17）也就是说int会基于base=？来将原字符串转换为整形，整形为10进制

bit_length()
a=10
b=a.bit_length()
b=4
该函数表示a这个数字至少要用几位二进制来表示（10的二进制为1010，总共4位二进制，60的二进制为111100，总共6位二进制）
注意：该函数只能用于数字，而不能用于字符串。

进程，线程.txt----------------------------------------------------------------------------------------------------
多线程 threading

创建子线程：
import threading
（主线程按照流程运行，当主线程即将结束时，会检验子线程是否已经完成，如果子线程没完成，主线程就会等待子线程完成后再结束）
实例化对象:
t1=threading.Thread(target=需要执行的函数名字,args=函数需要的参数)  （注意：args=  后面的参数必须是可迭代对象，如果说参数是一个数字的话，可以这么写（1，），本例的集合是一个可迭代对象，无参数的话不需要输入后面那段）
启动:
t1.start()
等待：
t1.join()该函数下面的主线程必须等t1运行完成后才能运行。

守护进程：setDaemon(True) 函数表示，一旦主线程结束以后，子线程也跟着结束。（注意：setDaemon一定要设置在start()之前。）
t1.setDaemon(True) 把t1设成守护进程

Thread实例对象的方法
  # isAlive(): 返回线程是否活动的。
  # getName(): 返回线程名。
  # setName(): 设置线程名。

threading模块提供的一些方法：
  # threading.currentThread(): 返回当前的线程变量。
  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。

继承式调用： （继承式创建子线程）
from threading import *
class Mythread（Thread）：
    def __init__(self):
        Thread.__init__(self)         # 把Thread的属性继承过来。
    def run(self):                       # 重写run方法，在继承Thread属性时，会把self.run()继承过来，一旦Mythread实例化，且start后，run函数便会在子线程内运行。

--------------------------------------------------------------------------------------------------------------------------------------------------
线程队列：一种数据结构  先进先出  FIFO
import queue
q=queue.Queue()      -----创建队列

q.put(12)                   -----放入数据
q.put("hello")
q.put({"name":"yuan"})

data1=q.get()              -----取出数据  12
data2=q.get()                                    hello
data3=q.get()                                    {"name":"yuan"}

加参数情况：
q=queue.Queue(5)  ------最多put5个参数，如果put第6个参数，那么主函数便会卡住，直到get取出一个值，主函数才能继续运行。
q.put("hello",False)  ------后面的参数False表示，如果q的参数已满，put不进去了，那么函数就会报错，而不是继续等待put。
q.get(block=False)  -------如果队列为空，get不到数据的话函数便会报错。


先进后出：
import queue
q=queue.LifoQueue()


优先级：  [数字，数据]   ------数字越小，越优先get数据，get出来的数据是一个列表，跟put进去的内容一样，可以通过索引的方式取出数据，即data=q.get()[1]。
q=queue.PriorityQueue()
q.put([3,12])
q.put([2,"hello"])
q.put([4,{"nmae":"yuan"}])
本例get出来的数据及顺序是：[2,"hello"]，[3,12]，[4,{"nmae":"yuan"}]


其他调用函数：
q.qsize()          ------q里面有多少个数据。
q.empty()        ------q是否为空，是的话True，不为空False。
q.full()             ------q是否为满。
q.get_nowait() 相当q.get(False)。
非阻塞 q.put(item) 写入队列，timeout等待时间。
q.put_nowait(item) 相当q.put(item, False)。
q.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号，只有收到这个信号后，join阻塞才会疏通。
q.join() 实际上意味着等到队列为空，再往下执行操作。
（task_done之前必须有put操作，也就是往队列里放入数据，这时候join不为空，join将阻塞，即使get出数据，join依然阻塞，只有执行q.task_done()之后，join才能疏通阻塞）

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
多进程 multiprocessing

创建子进程：
from multiprocessing import Process
构造：
Process([group [, target [, name [, args [, kwargs]]]]])
　　group: 线程组，目前还没有实现，库引用中提示必须是None； 
　　target: 要执行的方法； 
　　name: 进程名； 
　　args/kwargs: 要传入方法的参数。
一般用的都是P1=Process(target=函数名，args/kwargs=参数)

实例方法：
　　is_alive()：返回进程是否在运行。
　　join([timeout])：阻塞当前上下文环境的进程程，直到调用此方法的进程终止或到达指定的timeout（可选参数）。
　　start()：进程准备就绪，等待CPU调度
　　run()：strat()调用run方法，如果实例进程时未制定传入target，这star执行t默认run()方法。
　　terminate()：不管任务是否完成，立即停止工作进程

属性：
　　daemon：和线程的setDeamon功能一样  ------创建daemon的方法 P.daemon=True
　　name：进程名字。
　　pid：进程号。

------------------------------------------------------------------------------------------------------------------------------------------
进程队列 multiprocessing.Queue()

q=multiprocessing.Queue()

--------------------------------------------------------------------------------------
进程间的通信

管道  ------双向管道（可收发消息，类似于socket里面的conn）
from multiprocessing import Pipe
parent_conn，child_conn=Pipe() #这是两个双向管道，父级管道，子级管道

parent_conn.send("信息")   ------发消息
response=conn.recv()        ------收消息
conn.close()                       ------关闭管道

--------------------------------------------------------------------------------------
Manager 资源共享

with Manager() as manager:   ------用这种方法的话，下面就不用执行 close() 操作了，类似于with open("a","a") as b，即打开文件操作。
    d=manager.dict()      ------创建一个字典
    l=manager.list()        ------创建一个列表
（用这种方法创建的字典以及列表在进程间共享，即各个进程可以共同修改这些资源）

--------------------------------------------------------------------------------------
进程同步  同步锁Lock

from multiprocessing import Lock
lock=Lock()   ------创建进程锁
lock.acquire() ------获得锁
lock.release()  ------释放锁
（虽然进程间的内存等资源是独立的，但进程锁仍能影响全部进程，效果类似于线程锁）

--------------------------------------------------------------------------------------
进程池 apply---阻塞，同步方法      apply_async---异步方法

from multiprocessing import Pool
pool=Pool(5)   ------进程池内进程数为5。

for i in range(100):
      pool.apply_async(func=函数名1，args=参数，callback=函数名2)   ------用5个进程同时去跑函数1，如果不用进程池，需要for循环100次，但使用进程池后，只需跑20次即可。
	（callback，每次执行完函数1就会自动执行函数2，可以用来做日志，且函数1是在子进程内进行的，而函数2是在主进程内完成的）
进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。

--------------------------------------------------------------------------------------
协程 ------yield，协作式，非抢占式的程序，用户切换式（本质上就是一个线程）
协程的优势：1.没有切换的消耗，因为就一个线程   2.没有锁的概念，因为协程的方式不是抢占式
解决并发的一个很好的方式：协程加进程迭代器与生成器.txt----------------------------------------------------------------------------------------------------
迭代器跟可迭代对象的关系：迭代器就是可迭代对象。

生成器：使用yield返回，而不是return返回，且yield可以返回多次。
def test():
    yield 1
    yield 2
    yield 3
g=test()
print(g)
print(g.__next__())
print(g.__next__())
print(g.__next__())

t.send("abc")函数将把后面的字符串返回给上一个yield。

返回为：<generator object test at 0x0000026F08895A20>
1
2
3
生成器还可以这样创建：
generate__list=("哈哈%s"%i  for i in range(10))前面的"哈哈%s"%i 可以省去。然后想打印出generate__list的值，就要调用__next__()，每调用一次就返回一个值。

触发生成器的方法除了调用t.__next__()之外还有next(t)。

三元表达式：

x  if  (表达式)  else y     ====x为条件成立的返回值，y为条件不成立时的返回值。
例如：
name=“alex”
res= “美女” if name==“alex”else “帅哥”
print（res）==“美女”

列表解析：
egg=[]
for i in range(10):
    egg.append("鸡蛋%s"%i)
print(egg)==['鸡蛋0', '鸡蛋1', '鸡蛋2', '鸡蛋3', '鸡蛋4', '鸡蛋5', '鸡蛋6', '鸡蛋7', '鸡蛋8', '鸡蛋9']
上面例子可以通过列表解析完成：
["鸡蛋%s"%i   for i in range(10)  ]

上面的列表还可以加入个表达式，变成三元表达式：["鸡蛋%s"%i   for i in range(10)  if i < 5 ]，注意：该判断条件没有else，因为只能是三元表达式，而不能变成四元表达式。

生成器表达式：列表解析[i for i in range (10)]，将中括号 [ ] 改为（）就变成了生成器，然后就可以调用__next__()来取得返回值。

生成器的好处：可以满足及时需求，需要就生产，不占用太多内存。

t.send("abc")函数将把后面的字符串返回给上一个yield。





集合.txt----------------------------------------------------------------------------------------------------
在内存里面（id）：
字符串、列表、元组、字典都会改变内存位置，每执行一次print都会改变。
而数字不会改变。

集合：1.不同元素组成  2.无序  3.集合中的元素类型是不可变类型。
集合set={1，2，3},当set={1,2,2,3}时，默认set={1，2，3}
也可以直接这么创建集合：
s=set（“hello”）
print（s）=={“h”，“e”，“l”，“e”}
当用这种方法创建集合时可以往set（）里面放入列表、元组以及字典等（传入字典时只传入key值）。

set.pop()随即删除元素。
set.remone("ppp")删除指定元素，但不存在指定元素时会报错。
set.discard("ppp")删除指定元素，即使不存在指定元素时也不会报错。

s1.intersection(s2)交集，或者写成  s$s2，二者的共有部分。
s1.(union(s2))并集，或者写成  s|s2，将二者相加起来。
s1.difference(s2)差集，或者写成  s1-s2，s1减去二者的共有部分。
s1.symetric_difference(s2)交叉补集，或者写成  s1^s2，s1加上s2然后减去他们的共有部分。

s1.diierence_update(s2),相当于执行了s1=s1-s2的操作。后续集合函数中有_update也类似。

s1.isdisjoint(s2)是否不相交，是的话返回true，有相交的话返回false。（disjoin不相交）
s1.issubset(s2)s1是s2的子集吗，是的话返回true，否者返回false。
s1.issuperset(s2)s1是s2的父级吗，是的话返回true，否则返回false。

s1.update(s2),将s2加入到s1里面。

s=frozense("hello")用该方法创建的集合为不可变集合。

如果想简单地去重，可以使用这种方法：
name=["alex","alex"]
s=set(name)因为set里面不可以有相同地元素，所以会把重复的参数去除掉。
name=list(s)然后把集合转换回列表。
或者直接写成这样：name=list(set(name))
但是上面两种方法都会改变列表里面元素的顺序，如果不考虑顺序的话可以这么做。


CSS.txt----------------------------------------------------------------------------------------------------
1.行内式
行内式是在标记的style属性中设定CSS样式。这种方式没有体现出CSS的优势，不推荐使用。
<p style="background-color: rebeccapurple">hello yuan</p>

2.嵌入式
嵌入式是将CSS样式集中写在网页的<head></head>标签对的<style></style>标签对中。格式如下：
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        p{
            background-color: #2b99ff;
        }
    </style>
</head>

3 链接式
将一个.css文件引入到HTML文件中。
<link href="mystyle.css" rel="stylesheet" type="text/css"/>

4.导入式
将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，<style>标记也是写在<head>标记中，使用的语法如下：
<style type="text/css">
          @import"mystyle.css"; 此处要注意.css文件的路径
</style>　

注意：
      导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网
页的样式。这是导入式固有的一个缺陷。使用链接式时与导入式不同的是它会以网页文件主体装载前装载CSS文件，因此显示出来的网页从一开始就是带样
式的效果的，它不会象导入式那样先显示无样式的网页，然后再显示有样式的网页，这是链接式的优点。

css选择器：
<style>
    *{}，通用元素选择器，匹配任何元素。
    e{}，标签选择器，匹配所有使用e标签的元素，如：p { color:green; }。
    #id{}，ID选择器，匹配相应ID的元素。记住要在ID前面加上#。
    .class，class选择器，匹配所有class相同的元素，class类似于ID，每个元素的ID都不相同，但大家的class可以相同。
    div.class{}，两重限制，匹配div标签中class为class的元素。
    a，p，div.class{}，多重限制，队列匹配，匹配所有a、p以及div中class为class标签的元素。多元素选择器。
    div1 div2 div3，匹配div1里面的div2里面的div3里面的元素。后代元素选择器。
    div1>div2，子元素选择器，匹配所有div1元素的子元素div2。
    div1+div2，毗邻元素选择器，匹配与div1相邻的且在div1下方的div2的元素。
</style>

注意嵌套规则：
1.块级元素可以包含内联元素或某些块级元素，但内联元素不能包含块级元素，它只能包含其它内联元素。
2.有几个特殊的块级元素只能包含内联元素，不能包含块级元素。如h1,h2,h3,h4,h5,h6,p,dt。
3.li内可以包含div。
4.块级元素与块级元素并列、内联元素与内联元素并列。

属性选择器：
 E[att]             匹配所有具有att属性的E元素，不考虑它的值。（注意：E在此处可以省略，比如“[cheacked]”。以下同。）   p[title] { color:#f00; }
 E[att=val]      匹配所有att属性等于“val”的E元素                                 div[class=”error”] { color:#f00; }
 E[att~=val]    匹配所有att属性具有多个空格分隔的值、其中一个值等于“val”的E元素      td[class~=”name”] { color:#f00; }
 E[attr^=val]   匹配属性值以指定值开头的每个元素                     div[class^="test"]{background:#ffff00;}
 E[attr$=val]    匹配属性值以指定值结尾的每个元素                     div[class$="test"]{background:#ffff00;}
 E[attr*=val]    匹配属性值中包含指定值的每个元素                     div[class*="test"]{background:#ffff00;}


---------------------------------------------------------伪类(Pseudo-classes)CSS伪类是用来给选择器添加一些特殊效果-----------------------------------------------------
<style>
    a:link（没有接触过的链接）,正常状态。
    a:hover（鼠标放在链接上的状态）,用于产生视觉效果。
    a:active（在链接上按下鼠标时的状态）,用于表现鼠标按下时的链接状态。
    a:visited（访问过的链接）,用于阅读文章，能清楚的判断已经访问过的链接。
</style>
伪类选择器 : 伪类指的是标签的不同状态:

a ==> 点过状态 没有点过的状态 鼠标悬浮状态 激活状态
a:link {color: #FF0000} /* 未访问的链接 */

a:visited {color: #00FF00} /* 已访问的链接 */

a:hover {color: #FF00FF} /* 鼠标移动到链接上 */

a:active {color: #0000FF} /* 选定的链接 */ 格式: 标签:伪类名称{ css代码; }

CSS2.txt----------------------------------------------------------------------------------------------------
CSS文本属性：
font-size: 10px -------------------字体大小

text-align: center-----------------文本居中

line-height: 200px;   文本行高 通俗的讲，文字高度加上文字上下的空白区域的高度 50%:基于字体大小的百分比。
（当你有背景的时候，想要文字在背景上上下居中，可以让line-height等于背景的高）

vertical-align:－4px  设置元素内容的垂直对齐方式 ,只对行内元素有效，对块级元素无效

text-indent: 150px ---------------首行缩进

letter-spacing: 10px--------------字符间距

word-spacing: 20px--------------单词间距（英文单词）

text-transform: capitalize--------单词首字母大写


----------------------------------------------------------------------
CSS边框属性：
{width：200px；height：200px；border：10px  solid  red} -------------设置外围长宽都为200px的边框，边框
类型为【solid（连续型） dashed（断续型），可以使用border-style来选择线型】，颜色为red。
（当然还可以单独控制某一条边框，例如左边框，border-left）


----------------------------------------------------------------------
CSS列表属性：
ul,ol{   list-style: decimal-leading-zero;-------------- 01.text
         list-style: none;--------------------------------- text
         list-style: circle;--------------------------------- ○text
         list-style: upper-alpha;------------------------- A.text
         list-style: disc; } -------------------------------- ●text


----------------------------------------------------------------------
dispaly属性：
none
block
inline
span{display：inline-block} ---------------------将span内联标签转换为内联-块级标签。
display:inline-block可做列表布局，其中的类似于图片间的间隙小bug可以通过如下设置解决：
outer{
            border: 3px dashed;
            word-spacing: -5px;
        }


-----------------------------------------------------------------------
外边距和内边：
width和height设置的是初始背景大小。
border：10px ------背景之外加上一层10px厚的边框。
padding：10px ----背景层向外扩张10px。
margin：10px -----整个图像的最外层向外扩张10px，扩张区域显示为空白，主要用于分隔周围图像，也可以理解为元素与元素之间的间距。（当上下两个元素都加上margin时，会取最大的值作为它们的间距，当左右两个元素加上margin时，会把两个值相加而成为他们的间距）
（如果想要同时调节四个方向的边距可以这样做，margin{10px 10px 10px 10px}，相对应于上，右，下，左，即顺时针方向）
margin:10px 5px 15px 20px;-----------上 右 下 左
margin:10px 5px 15px;----------------上 右左 下
margin:10px 5px;---------------------上下  右左
margin:10px;    ---------------------上右下左
（margin的时候，margin的对象会去寻找边界，必须有边界才能有效果，比如说你想把一个小的正方形移动到一个大的正方形的中心，那么你必须在大的正方形外边加上一层边界，padding或者border都行）
（想要子级box居中，可以这样做margin：0 auto）

边框在默认情况下会定位于浏览器窗口的左上角，但是并没有紧贴着浏览器的窗口的边框，这是因为body本身也是一个盒子（外层还有html），在默认情况下，   body距离html会有若干像素的margin，具体数值因各个浏览器不尽相同，所以body中的盒子不会紧贴浏览器窗口的边框了，为了验证这一点，加上：
body{
    border: 1px solid; ----------------------------------给body加上一层1px的边框，以便看出body的大小以及位置。
    background-color: cadetblue;
}
>>>>解决方法：
body{
    margin: 0;
}


-----------------------------------------------------------------------
先来了解一下block元素和inline元素在文档流中的排列方式。

block元素通常被现实为独立的一块，独占一行，多个block元素会各自新起一行，默认block元素宽度自动填满其父元素宽度。block元素可以设置width、height、margin、padding属性；

inline元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。inline元素设置width、height属性无效。inline元素的margin和
padding属性。水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。

常见的块级元素有 div、form、table、p、pre、h1～h5、dl、ol、ul 等。
常见的内联元素有span、a、strong、em、label、input、select、textarea、img、br等。


-----------------------------------------------------------------------
float：【left，right】向左边浮动，向右边浮动。
clear：【left，right，none，both】清除浮动。

clear语法：
clear : none | left | right | both
取值：
none : 默认值。允许两边都可以有浮动对象
left : 不允许左边有浮动对象
right : 不允许右边有浮动对象
both : 不允许有浮动对象
但是需要注意的是：clear属性只会对自身起作用，而不会影响其他元素。
如果一个元素的右侧有一浮动对象，而这个元素设置了不允许右边有浮动对象，
即clear：right，则这个元素会自动下移一格，达到本元素右边没有浮动对象的目的。


------------------------------------------------------------------------
定位position：

1.fixed：在理论上，被设置为fixed的元素会被定位于浏览器窗口的一个指定坐标，不论窗口是否滚动，它都会固定在这个位置。
{position：fixd；bottom：10px；right：10px} ---------------------对象被定位在距离底部10px，右边10px的位置。

2.relative：使用top、left、bottom、right定位移动之后，原始位置照样占着，其他文档的位置不会发生变化。该定位是基于原始位置的。

3.absolute：使用top、left、bottom、right定位移动之后，该文档相当于使用了float，其他文档将会顶上去占住原定位文档的位置。
如果该文档的父级使用了定位，例如使用了position：relative或absolute，那么该文档将会以其父级文档作为参考对象来进行定位。如果其父级
文档没使用定位，那么该文档将会以body作为参考对象进行定位。（absolute之后，该文档将会脱离文档流，使用margin时将会按照原始位置来进行扩张）

margin:10px 5px 15px 20px;-----------上 右 下 左
margin:10px 5px 15px;----------------上 右左 下
margin:10px 5px;---------------------上下  右左
margin:10px;    ---------------------上右下左

可以使用 top:50% 来进行居中操作，需要注意的是，这里的50%指的是子级的上边缘距父级上边缘的距离。

盒子上下左右居中显示：
position:fixed;
            margin:auto;
            left:0;
            right:0;
            top:0;
            bottom:0;
            width:200px;
            height:150px;
            background: #ccc
------------------------------------------------------------------------
背景里面移动图片：
background：url（“图片”） non-repeat  50px  100px    -----------向右边移动50px，向下边移动100px。图片不重复显示。
Djongo.txt----------------------------------------------------------------------------------------------------
web框架，djongo：
（https://www.cnblogs.com/yuanchenqi/articles/6083427.html）

# 导入服务器
from wsgiref.simple_server import make_server
# 定义一个函数application，当有网站链接进来的时候执行该函数
def application(environ,start_response):
    # environ是一个包含了所有HTTP请求信息的dict对象
    print(environ["PATH_INFO"]) # 取出字典里面的参数path_info，该参数对应的是网站地址后面的信息
    # start_response是返回给用户的相应头，第一个参数是状态码，第二个参数是一个列表，里面的各个元组都是一对键值对，注意：每个响应头只发送一次，也就是说start_response函数只执行一次
    start_response("200 ok",[("Content-Type","text/html/xml/ppp"),("kk","pp")])
    # 返回一个列表给用户，里面的信息就是我们看到的网页信息，也就是body，响应体
    return [b"<h1>hello</h1>"]
# 创建服务器对象httpd，参数为地址，端口，执行函数，如不填地址，默认为本机地址，也就是127.0.0.1
httpd=make_server("127.0.0.1",8080,application)
print("Serving HTTP on port 8080...")
# 开启服务器
httpd.serve_forever()

HTTP返回的字典environ中各键值对对应存储的数据：
“QUERY_STRING”: "user=aa&pwd=bb"，username与password存储的位置。
“PATH_INFO”：“网站地址后面的信息”




=======================django的流程和命令行工具=======================
django
    #安装： pip3 install django

          添加环境变量

    #1  创建project
       django-admin startproject mysite

       ---mysite

          ---settings.py
          ---url.py
          ---wsgi.py

       ---- manage.py(启动文件)

    #2  创建APP
       python mannage.py startapp  app01

    #3  settings配置（静态文件配置）

       STATIC_URL = '/static/'

       STATICFILES_DIRS=(
            os.path.join(BASE_DIR,"statics"),
        )
（STATICFILES_DIRS里面的路径可以用STATIC_URL去代替，比如说你在html文件里要导入C:\\aa\bb.jpg，你会写src="C:\\aa\bb.jpg",假设这个时候STATICFILES_DIRS=C:\\aa，那么你可以这样写src="/static/bb.jpg"）
（除了上述的导入文件方法外，还可以这样配置静态文件，在html任意处（一般在head标签对里面）加上{% load staticfiles %}，这样做相当于导入了路径STATICFILES_DIRS，也就是你的静态文件static的路径，当你需要添加照片等静态文件时，可以这样写{% static %}）


    #5  使用模版
       render(req,"index.html")   ----------------------所有模板也就是html文件都放在template文件夹下面

    #6  启动项目
       python manage.py runserver  127.0.0.1:8090

    #7  连接数据库，操作数据
       model.py


============================问题解决============================
1.无法发送照片：
创建一个跟templates同层的目录static，然后在settings.py里面加入
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, "static"),
]
（主要原因就是html文件与照片不是绑在一起发送过去的，html文件发送过去后，照片等静态文件才会发送过去，两者还需对应起来，因此需要单独管理这些静态文件）

2.修改ip地址后无法访问网站：
找到settings.py里面的ALLOWED_HOSTS=["*"]---------括号里面加入"*"

3.path无法使用正则表达式：
django2.0版本还有的path为绝对匹配，需要正则匹配时导入模块 from django.urls import re_path，使用re_path就可以使用正则表达式了。

在正则表达式里，( )代表分组，括号里面的数据一定作为参数，也就是说views里面相对应的函数一定要写参数。当你使用(?P<name>规则)时，对应的分组为命名参数，views里面传入参数时一定要将参数名命名为括号里面的name。
例如：re_path( 'show_time/ (?P<b>[0-9])/ (?P<a>\w) ,views.show_time )--------------------分组第一个参数为b，第二个参数为a
那么在views对应的函数show_time里一定要有两个传入参数a，b--------------------------------def show_time(req,a,b):

4.怎么取出form表单返回的数据（相关函数）：
get方式提交的数据：form表单返回的数据存储在你定义的函数的参数req里面，例如，def register(req):，返回的数据就在req里面，req.GET是一个字典，可以通过req.GET.get(key)来获取你想要的信息，也可以直获取整个字典。
post方式提交的数据：借鉴get方式，返回的字典为 req.POST，取值方式为 req.POST.get(key)。
req.method---------找到数据提交方式（也就是用户访问服务器的方式）
注意一个常用方法：request.POST.getlist('')---------通常使用get获取的都是一个数据，只有getlist才能获取到完整的数据。

5.引用路由地址
<form action="/register/" method="post"> 与 <form action="http://127.0.0.1:8000/register/" method="post">效果是一样的，当你不写前面的地址的时候，系统会默认把上一次的前面的地址拿过来用。
但这个不能固定，一旦这个路径写固定了，我在urlpath那里改一下名字，比如说registers，这个路径就用不了了，一般这个位置用别名，例如：<form action="{% url   别名(假设是tag) %}" method="post">，然后在urls文件里，re_path('register/',views.register，name=“tag”)。
（这样我每次修改re_path里面的register的时候，就不必要再去修改html文件里的register，因为此时html里面的register用的是别名tag，它与re_path里面的register是相通的）

6.html与函数变量间的替换：
可以在html里面设置{{ time }}，然后在定义函数的时候创建一个变量t，最后返回的时候告诉render用t去替换time，return render(req,"haha.html",{"time":t})。
（如果参数为多个的话，可以在字典{ }里面加入多个键值对，但是如果变量太多的话，可以这样写，return render(req,"haha.html",locals())，这样的话你定义的变量就会自动与html文件里面的同名变量替换。)
（ps：return HttpResponse（字符串），返回给页面的是字符串）
（{"action":list}-----当传进去的参数为列表时，在html文件里面也可以使用 . 来访问，例如：{{ action.1 }}-----来访问action里面的第一个元素，而不是通过索引 [1] 来访问；如果是字典的话，可以这样访问{{ action.name }}，name为键，也就是通过 .key 的方式访问字典；当然 . 的用处还有很多，比如还可用来访问传入对象的属性等等）

7.文件引入：
（STATICFILES_DIRS里面的路径可以用STATIC_URL去代替，比如说你在html文件里要导入C:\\aa\bb.jpg，你会写src="C:\\aa\bb.jpg",假设这个时候STATICFILES_DIRS=C:\\aa，那么你可以这样写src="/static/bb.jpg"）
（除了上述的导入文件方法外，还可以这样配置静态文件，在html任意处（一般在head标签对里面）加上{% load staticfiles %}，这样做相当于导入了路径STATICFILES_DIRS，也就是你的静态文件static的路径，当你需要添加照片等静态文件时，可以这样写src=" {% static "filename" %} "）

8.分发：
导入模块：from django.urls import re_path,include
例如将所有以blog开头的url全部分发到blog应用里面：path("^blog/",include("blog.urls"))-----------(意思是所有以blog开头的url都会去blog文件夹下的urls文件里面找，当然，第一步会先到总项目urls文件里面找，然后再到分项目blog里面找)

第一步，创建一个属于blog自己的urls文件urls.py（一个大的应用分很多小块，blog博客是其中之一，还有支付系统，播放系统之类的）
第二步，在总项目urls文件里写上re_path("^blog/",include("blog.urls"))
（一旦有以blog开头的连接进来，django会将该连接交给blog文件夹下面的urls文件处理，注意，blog.urls里面的连接就不必要再写上blog了，比如连进来的连接是 blog/haha/qq，那么blog.urls里面的连接这样写re_path("haha/qq/, views.function)"，这是因为blog只作为刚开始的分发）



==========================HttpRequest（函数参数里面的那个req，def register（req）：）函数属性与方法==========================
# path：       请求页面的全路径，不包括域名
#
# method：     请求中使用的HTTP方法的字符串表示。全大写表示。例如
#
#                    if  req.method=="GET":
#
#                              do_something()
#
#                    elseif req.method=="POST":
#
#                              do_something_else()
#
# GET:         包含所有HTTP GET参数的类字典对象
#
# POST：       包含所有HTTP POST参数的类字典对象
#
#              服务器收到空的POST请求的情况也是可能发生的，也就是说，表单form通过
#              HTTP POST方法提交请求，但是表单中可能没有数据，因此不能使用
#              if req.POST来判断是否使用了HTTP POST 方法；应该使用  if req.method=="POST"
#
#
#
# COOKIES:     包含所有cookies的标准Python字典对象；keys和values都是字符串。
#
# FILES：      包含所有上传文件的类字典对象；FILES中的每一个Key都是<input type="file" name="" />标签中                     name属性的值，FILES中的每一个value同时也是一个标准的python字典对象，包含下面三个Keys：
#
#             filename：      上传文件名，用字符串表示
#             content_type:   上传文件的Content Type
#             content：       上传文件的原始内容
#
#
# user：       是一个django.contrib.auth.models.User对象，代表当前登陆的用户。如果访问用户当前
#              没有登陆，user将被初始化为django.contrib.auth.models.AnonymousUser的实例。你
#              可以通过user的is_authenticated()方法来辨别用户是否登陆：
#              if req.user.is_authenticated();只有激活Django中的AuthenticationMiddleware
#              时该属性才可用
#
# session：    唯一可读写的属性，代表当前会话的字典对象；自己有激活Django中的session支持时该属性才可用。

#方法
get_full_path(),   比如：http://127.0.0.1:8000/index33/?name=123 ,req.get_full_path()得到的结果就是/index33/?name=123
req.path:/index33

注意一个常用方法：request.POST.getlist('')

==============================HttpResponse对象=================================

对于HttpRequest对象来说，是由django自动创建的，但是，HttpResponse对象就必须我们自己创建。每个view请求处理方法必须返回一个HttpResponse对象。

HttpResponse类在django.http.HttpResponse

在HttpResponse对象上扩展的常用方法：

页面渲染：         render()（推荐）               render_to_response(),
页面跳转：         redirect("路径")--------（比如跳转到百度：路径为http://www.baidu.com；当然可以跳转到另一个url下，比如你写上"/login/"，他就会先到总项目文件的urls文件里面找到有login路径的函数，比如说re_path（"login/"，views.login），注意，redirect与re_path里面的路径必须完全匹配才能执行成功。）

locals()：    可以直接将函数中所有的变量传给模板
补充：


复制代码
-----------------------------------url.py

 url(r"login",   views.login),
 url(r"yuan_back",   views.yuan_back),

-----------------------------------views.py
def login(req):
    if req.method=="POST":
        if 1:
            # return redirect("/yuan_back/")
            name="yuanhao"

            return render(req,"my backend.html",locals())

    return render(req,"login.html",locals())


def yuan_back(req):

    name="苑昊"

    return render(req,"my backend.html",locals())

-----------------------------------login.html

<form action="/login/" method="post">
    <p>姓名<input type="text" name="username"></p>
    <p>性别<input type="text" name="sex"></p>
    <p>邮箱<input type="text" name="email"></p>
    <p><input type="submit" value="submit"></p>
</form>
-----------------------------------my backend.html
<h1>用户{{ name }}你好</h1>

#总结: render和redirect的区别:
#   1 if render的页面需要模板语言渲染,需要将数据库的数据加载到html,那么所有的这一部分
#     除了写在yuan_back的视图函数中,必须还要写在login中,代码重复,没有解耦.

#   2 the most important: url没有跳转到/yuan_back/,而是还在/login/,所以当刷新后
#     又得重新登录.



==============================模板语法============================
模板组成：html代码与逻辑控制代码

逻辑控制代码的组成：
1. 变量（使用大括号来引用变量）：{{ var_name }}

template与context对象：有逻辑控制代码的html文件即template；render（“html”，{{“time”：time  }} ）里面大括号的内容即context。

=====================Template和Context对象（使用命令行创建模板，然后替换参数）===================
>>> python manange.py shell  (进入该django项目的环境)
>>> from django.template import Context, Template
>>> t = Template('My name is {{ name }}.')---------创建模板t
>>> c = Context({'name': 'Stephane'})--------------创建上下文
>>> t.render(c)---------------------------------------变量替换，然后输出结果
'My name is Stephane.'


# 同一模板，多个上下文，一旦有了模板对象，你就可以通过它渲染多个context，无论何时我们都可以
# 像这样使用同一模板源渲染多个context，只进行 一次模板创建然后多次调用render()方法渲染会
# 更为高效：
# Low
for name in ('John', 'Julie', 'Pat'):
    t = Template('Hello, {{ name }}')
    print t.render(Context({'name': name}))
---------每次执行都要创建模板t

# Good
t = Template('Hello, {{ name }}')
for name in ('John', 'Julie', 'Pat'):
    print t.render(Context({'name': name}))
---------每次调用的都是之前创建的模板t，更高效

=======================================深度查找========================================
万能的句点号: .
在template模板里面，{{ items.你想访问的内容 }}
#最好是用几个例子来说明一下。
# 首先，句点可用于访问列表索引，例如：

>>> from django.template import Template, Context
>>> t = Template('Item 2 is {{ items.2 }}.')
>>> c = Context({'items': ['apples', 'bananas', 'carrots']})
>>> t.render(c)
'Item 2 is carrots.'

#假设你要向模板传递一个 Python 字典。 要通过字典键访问该字典的值，可使用一个句点：
>>> from django.template import Template, Context
>>> person = {'name': 'Sally', 'age': '43'}
>>> t = Template('{{ person.name }} is {{ person.age }} years old.')
>>> c = Context({'person': person})
>>> t.render(c)
'Sally is 43 years old.'

#同样，也可以通过句点来访问对象的属性。 比方说， Python 的 datetime.date 对象有
#year 、 month 和 day 几个属性，你同样可以在模板中使用句点来访问这些属性：

>>> from django.template import Template, Context
>>> import datetime
>>> d = datetime.date(1993, 5, 2)
>>> d.year
1993
>>> d.month
5
>>> d.day
2
>>> t = Template('The month is {{ date.month }} and the year is {{ date.year }}.')
>>> c = Context({'date': d})
>>> t.render(c)
'The month is 5 and the year is 1993.'

# 这个例子使用了一个自定义的类，演示了通过实例变量加一点(dots)来访问它的属性，这个方法适
# 用于任意的对象。
>>> from django.template import Template, Context
>>> class Person(object):
...     def __init__(self, first_name, last_name):
...         self.first_name, self.last_name = first_name, last_name
>>> t = Template('Hello, {{ person.first_name }} {{ person.last_name }}.')
>>> c = Context({'person': Person('John', 'Smith')})
>>> t.render(c)
'Hello, John Smith.'

# 点语法也可以用来引用对象的方法。 例如，每个 Python 字符串都有 upper() 和 isdigit()
# 方法，你在模板中可以使用同样的句点语法来调用它们：
>>> from django.template import Template, Context
>>> t = Template('{{ var }} -- {{ var.upper }} -- {{ var.isdigit }}')
>>> t.render(Context({'var': 'hello'}))
'hello -- HELLO -- False'
>>> t.render(Context({'var': '123'}))
'123 -- 123 -- True'

# 注意这里调用方法时并没有使用圆括号，而且也无法给该方法传递参数，所以你只能调用不需参数的方法。


=====================================变量的过滤器filter=====================================
使用{{ }}的时候，对传进去的内容进行进一步处理：
语法格式：      {{ obj | filter : param }}-------object为传进去的内容，filter为过滤器，param为过滤器所需的参数，当然有的过滤器不需要参数。
# 1  add          ：   给变量加上相应的值
   #
   # 2  addslashes   :    给变量中的引号前加上斜线
   #
   # 3  capfirst     :    首字母大写
   #
   # 4  cut          ：   从字符串中移除指定的字符
   #
   # 5  date         ：   格式化日期字符串
   #
   # 6  default：“name”      ：   如果值是False（0，空，这些都属于False）,就替换成设置的默认值（这里为“name”），否则就是用本来的值
   #
   # 7  default_if_none:“name2”：  如果值是None，就替换成设置的默认值（这里为“name2”），否则就使用本来的值
   #
   # 8  safe           :     将安全机制关掉，意思就是我传进来的是什么就按照什么显示，而不是被转为字符串，例如我传进一个链接，那就应该是可以点击的，而不应该被转为普通的字符串来显示。还有就是告诉浏览器，传进去的内容是安全的。


#实例:

#value1="aBcDe"
{{ value1|upper }}<br>-------ABCDE

#value2=5
{{ value2|add:3 }}<br>--------8

#value3='he  llo wo r ld'
{{ value3|cut:' ' }}<br>--------helloworld

#import datetime
#value4=datetime.datetime.now()
{{ value4|date:'Y-m-d' }}<br>

#value5=[]
{{ value5|default:'空的' }}<br>-----------如果传进去的值为空，返回default定义的内容
#value6='<a href="#">跳转</a>'


{% autoescape off %}
  {{ value6 }}             ---------------------与safe作用是一样的（{{ value6|safe }}<br>），告诉浏览器这个内容是安全的。
{% endautoescape %}

{{ value6|striptags }}

#value7='1234'------------------------------传进来一个字符串
{{ value7|filesizeformat }}<br>--------------得到
{{ value7|first }}<br>------------------------取出来第一个字符
{{ value7|length }}<br>---------------------得到它的长度
{{ value7|slice:":-1" }}<br>------------------切片

#value8='http://www.baidu.com/?a=1&b=3'
{{ value8|urlencode }}<br>-----------------对传进来的内容进行编码
    value9='hello I am yuan'

===================================tag标签的使用==================================
语法：{% tags %}

----------------------------------------------------------

判断：
{% if 条件 %}
      content------------条件满足，就会显示content
{% endif %}

----------------------------------------------------------

for循环：
{% for object in list %}
      content
{% endfor %}

例子：
list=[1,2,3,4,5,6,7,8,9]
{% for name in list %}
<h1>{{name}}</h1>------------------将list里面的元素逐行打印出来
{% endfor %}
（值得注意的是，如果你将{{name}}写成name，那么会打印9行字符串name）

{{forloop.counter0}}----索引号，比如把他放在name前面，就会出现1 name，2 name，默认从1开始计算，在counter后面加个0，变成counter0便可以从0开始。
{% empty %}-----------加在endfor之前，这样的话，for循环里面的列表如果为空时，empty至endfor之间的内容才会显示。
例如：
{% for name in list %}
      abc-------------------如果列表为空，即不会进入循环，所以不会打印abc
{% empty %}
      efg-------------------此时，efg就会打印出来。如果列表不为空，efg即不会显示
{% endfor %}

注意事项：
#{% if %} 标签接受and，or或者not来测试多个变量值或者否定一个给定的变量
#{% if %} 标签不允许同一标签里同时出现and和or，否则逻辑容易产生歧义，例如这个标签是不合法的：{% if obj1 and obj2 or obj3 %}
#在标签里添加reversed来反序循环列表：
    {% for obj in list reversed %}
    ...
    {% endfor %}
#{% for %}标签可以嵌套
#系统不支持中断循环，系统也不支持continue语句
#forloop.revcounter将forloop.revcount的序列反转过来，例如3 name，2 name，1 name
#forloop.revcounter0
#forloop.first，第一次循环时为True，超过一次循环后为False

----------------------------------------------------------

{% csrf_token %}----------相当于安全钥匙，只有在form表单里面加入这句话，网页提交过来的数据才能被认可。流程：后台将带有安全钥匙的html发到网页端，网页填好数据后再通过submit提交数据，同时带着这个钥匙返回，后台认为该数据可靠，然后接收数据。
（当然，可以在django的settings文件里面将'django.middleware.csrf.CsrfViewMiddleware'这行代码注释掉，这样做就不需要输入{% csrf_token %}，而网页也可以提交数据了）

实际上在render渲染的时候，它会把{% csrf_token %}渲染成下面的这个input标签，然后网页端submit的时候，该标签就会随同其他input标签一起返回给后台进行处理。
<input type="hidden" name="csrfmiddlewaretoken" value="sWvW2o5yxwJfoHbRKmOUDfOobsH62I8EkanUndeVvn4AsRzijSTvaAf7qplCGR8y">--每次的value值都是不同的。

----------------------------------------------------------

{% url  "name" %}-----name为url文件里面你命名的路径，例如你在主项目url里面写了re_path("aa\"，views.aa，name="cc")，那么这个路径"aa\"，可以用"cc"来表示，而这个“cc”也就是{% url  ”cc“ %}里面的”cc“，这整个{% url  ”cc“ %}代码渲染出来后就是”/aa/“。

----------------------------------------------------------

{% with %}---------用更简单的变量名替代复杂的变量名
比如我有一个很长的变量名，例如ABCDEFG，每次引用的时候都得这样用{{ ABCDEFG }}，太麻烦了，这个时候可以这样写：
{% with ABC=ABCDEFG %}
{{ ABC }} -----------这个时候{{ ABC }}就等同于{{ ABCDEFG }}
{% endwith %}

---------------------------------------------------------

{% verbatim %}----------禁用render，也就是该标签里面的内容不会被渲染，里面是什么就是什么，比如你就想显示{{ abc }}而不是把它当作一个变量，这个时候就可以使用该标签了。
{{ hello }} ----------------这个时候屏幕显示的就是{{ hello }}
{% endverbatim %}

---------------------------------------------------------

{% load %}


自定义标签：filter和simple_tag ----------自定义一个标签来获得我们想要的功能
步骤：
1.在app中创建templatetags模块
2.创建任意.py文件，如my_tags.py
3.在.py文件里面导入模块：
from django import template
from django.utils.safestring import mark_safe
register=template.Library()    #register的名字是固定的，不可改变

@register.filter--------自定义过滤器
def filter_multi(x,y):
    return x*y
@register.filter--------自定义标签
def filter_multi(x,y):
    return x*y

4.在html文件里面导入文件{% load my_tags%}，开始在html文件里面调用自定义filter或simple_tag
{% load my_tags %}

{{ 变量|自定义filter：参数}}-----自定义过滤器的使用（上面定义的filter名称为filter_multi，做加法运算，里面需要传进参数x，y，x为 {{ 变量|自定义filter：参数}} 里面的“变量”，y为“参数”，如果需要传进去多个参数，可以以列表的形式传进去，但“参数”那里不能直接传进去一个列表，你必须在views文件中将列表赋予给一个变量，比如aa，再把aa赋值给 {{ 变量|自定义filter：参数}} 里的“参数”）
（自定义filter有个限制：“参数”里面只能传进一个参数）
{% simple_tag 参数 %}----------自定义simple_tag的使用（这里的参数如果需要传进去多个参数，可以这样传：参数1 参数2 参数3，即以空格为间隔传进多个参数）
（限制：不能用在控制语句里面）
5.在settings中的INSTALLED_APPS配置当前app（就是在里面加上自己app的名字，比如本次的app是blog），不然django无法找到自定义的simple_tag.

---------------------------------------------------------------------
继承：

被继承html：
{% block content2 %}-------content2为自定义block的名字
    内容------------------------在被继承html中加上block块，这个block里面的内容正常显示，但无法被继承，也就是说如果我在其他html里面继承了该html，这个block里面的内容不会被继承过去
{% endblock %}

继承html：
{% extends “被继承html名称”%}---------该标签必须在最上面
{% block content2 %}
    内容------------------------在继承html里面，其他内容与被继承文件是一样的，但是block里面的内容需要自己写，这部分自己写的block内容会自动替换掉被继承文件里面的同名block内容
{% endblock %}

访问被继承html（也就是父模板）里block的内容，可以这样访问，{{ block.super }}---------访问父模板block里面的内容

--------------------------------------------------------------------
include标签：
{% load staticfiled %}
{% include “引用的html文件名”%}-----------在html文件里引用其他html文件的内容，但记得先在上面添加load标签

--------------------------------------------------------------------
（利用python进行数据库操作，orm对表单的增删改查）
数据库模型：model---------------orm（object relation mapping对象关系映射表）

一个实例就是一条记录：
class aa（）：
id=
name=

当这个类aa实例化的时候传进去参数便可以产生一个实例，这个实例实际上就是一条纪录，即表的一条纪录
（而创建的这个类实际上就是在数据库里创建一张表）

表的添加：
创建表顺序：
1.点开app里面的models

2.创建一个类：
# create table book(
#     name varchar(20),
#     price float(4,2),
# )
#下面将用python创建一个与上述内容相同的表
class Book(models.Model):
    # name varchar(20)，下面用CharField来表示字符串类型，max_length=20表示最大长度为20
    name=models.CharField(max_length=20)
    # IntegerField为整数类型，长度可不设，默认为十一位
    price=models.IntegerField()
    # DateField为时间类型
    pub_date=models.DateField()
    # 创建一个外键
    publish=models.ForeignKey（"Publish"）
3.在命令行运行manage.py文件，python manage.py makemirations

4.可以在app下面的migrations文件夹里面看到一个新建的文件

5.再次运行manage文件，python manage.py migrate

6.可以看到manage文件上方出现一个数据库db.sqlite3，因为此时系统默认使用的数据库为sqlite

（生成同步数据库的脚本：python manage.py makemigrations  ；同步数据库:  python manage.py migrate   ）

查看这个db数据库的操作：
1.点开pycharm右边的database，单击+，选择data source里面的sqlite（或者MySQL）
2.在弹出来的面板左边选择sqlite，右边单击apply，然后ok（mysql的话要选择接口，还要填账号密码）
3.将manage文件上方的db.sqlite3文件拖拽到右边的database那里（mysql的话省略这一步）
4.点开main，然后找到对应的app，双击
5.可以点击的页面上方的加号来添加一条纪录

表记录的添加：
方式一：在views函数里面定义一个函数，用于比如人访问你的时候执行这个函数，然后在里面对数据库类进行实例化
def shili(request):
    b=Book(参数，比如author=“yuan”，price=88)----------创建一个实例b
    b.save()-----------------将数据保存到数据库里面
方式二：
def shili(request):
    Book.objects.create(参数，例如name=，price=，author=)----------语句一旦执行就会将数据自动保存到数据库里面

表记录的删除：
Book.objects.filter(参数，即选择是哪一条纪录，比如author=“yuan”).delete()



表记录的修改：
方式一：
Book.objects.filter(参数，即选择是哪一条纪录，比如author=“yuan”).update（修改内容，price=99）-------修改所有的author=“yuan”的行，返回的是一个QuerySet对象
方式二：
b=Book.objects.get(参数，即选择是哪一条纪录，比如author=“yuan”) ------仅修改一行，返回的是一个model对象
b.price=120
b.save()
（一般用方式一，效率高，save方法调用时会给所有值重新赋值，即便有的值你没有修改，因此方式二效率不高）

查看每一步的底层raw sql语句：
1.先在settings文件里面加入下列：
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}

表记录的查询：
a=Book.objects.filter(条件，例如id=2)--------返回queryset集合对象（filter里面还可以这样写来筛选价格大于50的书，filter（price__gt=50），小于的话是price__lt，又比如想取出名字里面包含p的书本，可以这样写filter(name__contain="p"，__icontain的话不区分大小写，这些都可以通过__来查询使用)）
a=Book.objects.all() ----------查询Book的所有信息，返回的a为一个queryset集合对象，可以通过循环来取出每个对象（可以对该对象进行切片操作，例如[::2]，意思时每隔一个取一个）
a=Book.objects.first()---------返回集合对象的第一个
a=Book.objects.last()---------返回集合对象的最后一个
a=Book.objects.get(条件)-------返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。
----------对初步筛选的结果进行二次筛选-----------
values：Book.objects.filter(条件，例如id=2).values("name","price")------找到所有id=2的对象，然后只取出该对象的name值和price值，返回形式为一个queryset，里面是一个个的字典，{“name”：“啊”，“price”：1}
values_list：与values一样，但返回的是一个queryset列表，列表里面是一个个的元组，[ ("a",1)，("b",2) ]
exclude：Book.bojects.exclude(id=2)-----找出所有id不是2的，相当于集合id=2的补集
distinct：Book.bojects.all().values("name").distinct()------先取出所有的name，然后去除相同的name，通常与values合用
order_by(*field):      对查询结果排序，例如按照id来排序，order_by(id)。
reverse():             对查询结果反向排序
distinct():            从返回结果中剔除重复纪录
values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列
count():              返回数据库中匹配查询(QuerySet)的对象数量。
exists():             如果QuerySet包含数据，就返回True，否则返回False。

主表.子表_set----------通过主表去访问子表（主表.子表_set.all()---返回一个qureyset对象）

-----------------------------------数据库配置------------------------------------

----------------简介--------------------
1    django默认支持sqlite，mysql, oracle,postgresql数据库。
     <1> sqlite

            django默认使用sqlite的数据库，默认自带sqlite的数据库驱动 , 引擎名称：django.db.backends.sqlite3

     <2> mysql

            引擎名称：django.db.backends.mysql

2    mysql驱动程序
   MySQLdb(mysql python)
   mysqlclient
   MySQL
   PyMySQL(纯python的mysql驱动程序)

----------------------------------------
连接mysql数据库：

1.设置配置文件settings.py：
DATABASES = {

    'default': {

        'ENGINE': 'django.db.backends.mysql',

        'NAME': 'books',    #你的数据库名称

        'USER': 'root',   #你的数据库用户名

        'PASSWORD': '', #你的数据库密码

        'HOST': '', #你的数据库主机，留空默认为localhost

        'PORT': '3306', #你的数据库端口

    }

}

2.设置完后，再启动我们的Django项目前，我们需要激活我们的mysql。

然后，启动项目，会报错：no module named MySQLdb

这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb对于py3有很大问题，所以我们需要的驱动是PyMySQL

所以，我们只需要找到项目名文件下的__init__,在里面写入：

import pymysql
pymysql.install_as_MySQLdb()

问题解决！

（错误：django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.13 or newer is required; you have 0.9.3.
File "C:\Users\82021\AppData\Local\Programs\Python\Python37\lib\site-packages\django\db\backends\mysql\base.py", line 36, in <module>
    raise ImproperlyConfigured('mysqlclient 1.3.13 or newer is required; you have %s.' % Database.__version__
解决方案：将该文件夹下的if version...注释了即可
)

（错误：AttributeError: 'str' object has no attribute 'decode'
File "C:\Users\82021\AppData\Local\Programs\Python\Python37\lib\site-packages\django\db\backends\mysql\operations.py", line 146, in last_executed_query
    query = query.decode(errors='replace'
解决方案：将decode改为encode
)


HTML.txt----------------------------------------------------------------------------------------------------
HTML  ---  htper text markup language  ---  超文本标记语言
超文本就是指页面内可以包含图片、链接，甚至音乐、程序等非文字元素。
标记语言：标记（标签）构成的语言。
网页==HTML文档，由浏览器解析，用来展示。
<!DOCTYPE html>告诉浏览器下面的代码全部按照标准去渲染。

<>标签语言
<head>标签体<head>

框架：
<html>
<head>
    <meta charset="UTF-8">
    <title>Title</title>---------在网页上显示标题。
</head>
<body></body>
</html>

<head>标签体</head>闭合标签
<标签体>自闭合标签

<h1 name="alex"> hello </h1>标签头里面的name是标签的属性，属性只能出现在开始标签或自闭合标签中。
属性名字全部小写，属性值必须使用双引号或者单引号包裹，如果属性值和属性名完全一样，直接写属性名即可。

方法：
<input type="text" readonly>  input，在文本中出现搜索框，类型是文本，readonly表示只读，这是个自闭合标签，也可以只写input。
<h1>text<h1> h1相当于标题，显示出来的文本会比较大。
<h2>text<h2> h2下一级标题，显示出来的文本会比较小。(以此类推，还有h3,h4,h5,h6......)
<script>
    alert(text) ---------------------弹窗
<script>


----------------------------------------------<head>标签------------------------------------------------
<meta>
         meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name 属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。

        1: name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。
<meta name="keywords" content="meta总结,html meta,meta属性,meta跳转">
<meta name="description" content="老男孩培训机构是由一个老的男孩创建的">

        2: http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。
<meta http-equiv="Refresh" content="2;URL=https://www.baidu.com"> //(注意后面的引号，分别在秒数的前面和网址的后面)
<meta http-equiv="content-Type" charset=UTF8">
<meta http-equiv = "X-UA-Compatible" content = "IE=EmulateIE7" />

<meta http-equiv="refresh" content="2;URL=https://www.baidu.com"> ------两秒后跳转到百度网站。
<meta http-equiv="X-UA-Compatible"  content = "IE=EmulateIE7"/>  --------加上此标签之后，可兼容IE7。
<meta http-equiv="content-type"  charset = "UTF-8" >
<meta name="keywords" content="关键词"> --------------- 通过里面的关键词可以搜索到本网站。
<meta name="description" content="内容">  --------------- 当你搜索出本网页之后，不用点进去就可以看到一些对本网页进行描述的内容。

非meta标签
<link rel="stylesheet" href="css.css">-------------
<script src="hello.js"></script>　-----------------将上面这两个标签加入到head标签下表示引入css和js。

<title>oldboy</title> ------------------------------网页标题
<link rel="icon" href="http://www.jd.com/favicon.ico"> ----------------标题旁边的图标，后面的href是导入图标的位置。

-----------------------------------------------<body>标签-----------------------------------------------
<h1>text</h1>  h标签独占一行，也就是说如果同一行你还写了<h2>，打印出来之后依然是h1占一行，h2占一行。

在body标签中也可以直接写上文本，那么打印出来的内容就是你输入的内容。需要注意的是你输入的内容会打印在同一行上，你可以通过<br>来实现换行。（</br>加上斜杠也是可以的，效果不变）

<p>text</p> p标签的内容也会独占一行。而且上下行之间的距离会跟普通换行时不一样。

<b>text</b> 标签的内容会进行加粗，但不进行换行。
<strong>text</strong> 跟b标签效果一样。
<strike>text</strike> 在text上加横线。
上面三个是内联标签，也就是效果范围是自己拥有的字符。与之对应的是块级标签，自己独占一行，效果作用于整行。

<em>text</em> 斜体。
<sub>text</sub>下标。
<sup>text</sup>上标。
<hr> ------------  横线。

<div>text</div>  没有任何自带效果，所以可以根据自己的需要添加任意效果。
<div style="color: #ff7292  ;  background: #e554ff  ;  height:20px  ;  width:10cm ">hello</div> 在里面可以调任意想要的效果。
<span>text</span> 与div标签都是没有自带效果的，它是内联标签，效果仅限于自己所拥有的字符。div为块级标签。

特殊字符：
< &lt;
> &gt；
"  &quot；
版权标签 &copy;  &reg;
空格 &nbsp；
（需要时可上网搜索HTML特殊字符表）

块级标签可以内嵌内联标签也可以内嵌块级标签，如：
<div>
    <span>
    </span>
</div>
内联标签可以内嵌内联标签，但不能内嵌块级标签。

<img>图形标签
<img scr="路径"   alt="如果浏览器无法显示图片，图片将会替换成alt里面文本"   title="鼠标悬浮于图片上，会显示title的内容">
src: 要显示图片的路径。
alt: 图片没有加载成功时的提示。
title: 鼠标悬浮时的提示信息。
width: 图片的宽。
height:图片的高 (宽高两个属性只用一个会自动等比缩放。)

<a>超链接标签(锚标签)：
<a href="网址">text</a> 单击text原网页将跳转到新网页。
<a href="网址" target="_blank">text</a> 单击text会另外打开一个网页。
（text内容可以是图片）

利用a标签实现网页回到顶部：
<div  id="abc">text</div> ------给text一个特定的id，当然，前面的div可以是img也可以是a等等，id可以用于很多地方。
<a href="#abc">text</a>  ------单击text会跳转到id=abc的地方，写上#的目的是告诉浏览器直接在本页面进行跳转。

列表标签：
ul(无序列表)标签：
<ul>
    <li>uuu</li>
    <li>123</li>
    <li>abc</li>
</ul>
效果：
-uuu
-123
 -abc

ol(有序列表)标签：
<ol>
    <li>uuu</li>
    <li>123</li>
    <li>abc</li>
</ol>
效果：
1.uuu
2.123
3.abc

dl(定义列表)标签：
<dl>
    <dt>第一章</dt>
    <dd>第一节</dd>
    <dd>第二节</dd>
    <dd>第三节</dd>
</dl>
效果：
第一章
    第一节
    第二节
    第三节

<table>表格标签：
border: 表格边框。
cellpadding: 内边距。
cellspacing: 外边距。
width: 像素 百分比。（最好通过css来设置长宽）
<tr>: table row
         <th>: table head cell
         <td>: table data cell
rowspan:  单元格竖跨多少行
colspan:  单元格横跨多少列（即合并单元格）
<th>: table header <tbody>(不常用): 为表格进行分区。

<form>表单标签：与server端打交道，将数据发送给server端。
<form action="服务器地址" method="提交方式get或者post" enctype="multipart/form-data"> ---后面的enctype是上传文件时需要加进去的。
    用户名<input type="text" name="usernmae" placeholder="在输入框内显示的内容" disabled> --明文输入，后面的disabled表示不让用户进行任何操作，输入框会变成灰色。
    密码<input type="password" name="password" placeholder="在输入框内显示的内容"> --------密文输入
    多选框<input type="checkbox" name="hobby" checked> -----多选框，?，后面的checked表示默认选择。
    单选框<input type="radio" name="hobby">
    选择文件<input type="file" name="put_file"> --------------选择需要上传的文件。
	<input type="text" value="默认输入的内容">
    重置数据<input type="reset" value="按钮显示的内容"> -----将input的内容重置。
    提交数据<input type="submit" value="按钮显示的内容"> ---将input的内容打包发送给sever端。（发送一个字典，键是name，值是value，输入的内容会赋值给value，而复选框或者单选框所选择的选项，会直接把里面的name以及value组成字典发送出去，所以里面需要写上一个value）
    提交数据<input type="button" value="按钮显示的内容"> ---在绑定内容之前，button键只能看，不会有任何功能。
    <button value="按钮显示的内容">text</button>button按钮，需要绑定功能。
    select标签，下拉列表:
    <select name="province" multiple  size="2"> -------multiple表示可以多选，size=2表示只显示两个选项，因此可以通过拉动列表来看其他选项。
        <option value="beijing">北京市</option>
        <option value=""  selected>上海市</option> ----selected表示默认选择。
        <option value="">天津市</option>
        <option value="">广东省</option>

        <optgroup label="ABCD"> ------------------------相当于在省份ABCD下面加入了A、B、C、D市，但该省份不能选择，只能选择下面的城市。
            <option value="">A市</option>
            <option value="">B市</option>
            <option value="">C市</option>
            <option value="">D市</option>
        </optgroup>
    </select>
（在js中，通过 .selectedIndex可以找到你选择的option标签的索引位置，然后通过索引 .options[ .selectedIndex]获取到你选择的标签，二级联动，选择省份，城市）
    <textarea name="desc" rows="10" cols="10">text</textarea> ------文本框，当你写了后面的text后，文本框中相当于默认写了text。

    <label for="www">姓名</label>
    <input id="www" type="text"> -----------------这两个标签将会连接起来，相当于在input前面加了个姓名，这时候点击姓名就跟点击输入框一样。


    <table border="1px" cellpadding="5px" cellspacing="50px"> ----------table标签，border：加边框，cellpadding: 内边距，cellspacing: 外边距。px：像素。
        <thead> ----------------------------------------------------------------表头。
        <tr> ---------------------------------------------------------------------tr另起一行。
            <th>111</th> -------------------------------------------------------th以标题形式书写，内容居中。
            <th>222</th>
            <th>333</th>
        </tr>
        </thead>
        <tbody> ----------------------------------------------------------------表体。
        <tr>
            <td rowspan="2">1111111</td> -----------------------------------td普通形式书写内容，内容不会居中。

，rowspan="2"，内容独占两行。
            <td>2222222</td>
            <td>3333333</td>
        </tr>
        <tr>
            <td colspan="2">1111111</td> ------------------------------------colspan="2"，内容独占两列。
            <td>2222222</td>
            <td>3333333</td>
        </tr>
        </tbody>
    </table>
</form>

单选框例子：
音乐<input type="radio" name="hobby" value="music">
电影<input type="radio" name="hobby" value="movie"> ----------当type是radio，而name相同时，选项只能选择一个。


----------------------------------------------------------------------------------------------------------------------------------------------
给input或者button等绑定函数：
（下面是一个搜索按钮的实例，在input内输入网址，通过button键点击搜索，从而打开网站）
<input type="text" id="id1"> ----------------------------------------给input标签绑定id。
<button id="id2" onclick="open2">搜索</button> ----------------onclick，只要点击button键便会触发open2函数。

定义函数：
function  open2()
{
ele=document.getElementById("id1") ------------------------------ele就是id等于id1的标签。
value=ele.value ------------------------------------------------------获取ele的value（即input输入框内输入的内容）。
open（value）--------------------------------------------------------打开value对应的网页。
}IO多路复用，select监听.txt----------------------------------------------------------------------------------------------------
IO多路复用   select  poll  epoll  (windows下只有select，epoll是优化最好的，可以在Linux下使用)

import select
r,w,e=select.select（[sk，]，[]，[]，5）   ------函数处于监听状态，一旦sk触发，函数就会往下执行，5表示每隔5秒就会往下执行函数。

触发方式：1.水平触发   2.边缘触发
socket属于水平触发，也就是一旦触发就会一直触发下去，直到产生新的变化。
import select
from socket import *
sk=socket(AF_INET,SOCK_STREAM)
sk.bind(("127.0.0.1",8080))
sk.listen(5)
inp=[sk,]
while 1:
    r,w,q=select.select(inp,[],[],2)
    for i in r:
        conn,add=i.accept()   -------注意，一旦把这行注释掉，函数就会进入一个死循环，不断地print，那是因为此时sk处于触发状态，select不发生阻塞，除非sk把链接成功建立起来，即成功建立了conn，这时候sk再次恢复到待触发状态。
        print("xixi")
    print("------")


单线程下多连接服务器：
import select
from socket import *
sk=socket(AF_INET,SOCK_STREAM)
sk.bind(("127.0.0.1",8080))
sk.listen(5)
inp=[sk,]
while 1:
    r,w,q=select.select(inp,[],[],2)
    for i in r:
        if i==sk:
            conn,addr=i.accept()
            print(conn)
            inp.append(conn)
        else:
            data=i.recv(1024)
            print(data.decode("utf-8"))
            i.sendall(input("send:").encode("utf-8"))
客户端：
import select
from socket import *
sk=socket(AF_INET,SOCK_STREAM)
sk.connect(("127.0.0.1",8080))
while 1:
    sk.sendall(input("send:").encode("utf-8"))
    print(sk.recv(1024).decode("utf-8"))


------------------------------------------------注释版-------------------------------------------------
# select 模拟一个socket server，注意socket必须在非阻塞情况下才能实现IO多路复用。
# 接下来通过例子了解select 是如何通过单进程实现同时处理多个非阻塞的socket连接的。
#server端


import select
import socket
import queue

server = socket.socket()
server.bind(('localhost',9000))
server.listen(1000)

server.setblocking(False)  # 设置成非阻塞模式，accept和recv都非阻塞
# 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们
# BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。
msg_dic = {}
inputs = [server,]  # 交给内核、select检测的列表。
# 必须有一个值，让select检测，否则报错提供无效参数。
# 没有其他连接之前，自己就是个socket，自己就是个连接，检测自己。活动了说明有链接
outputs = []  # 你往里面放什么，下一次就出来了

while True:
    readable, writeable, exceptional = select.select(inputs, outputs, inputs)  # 定义检测
    #新来连接                                        检测列表         异常（断开）
    # 异常的也是inputs是： 检测那些连接的存在异常
    print(readable,writeable,exceptional)
    for r in readable:
        if r is server:  # 有数据，代表来了一个新连接
            conn, addr = server.accept()
            print("来了个新连接",addr)
            inputs.append(conn)  # 把连接加到检测列表里，如果这个连接活动了，就说明数据来了
            # inputs = [server.conn] # 【conn】只返回活动的连接，但怎么确定是谁活动了
            # 如果server活动，则来了新连接，conn活动则来数据
            msg_dic[conn] = queue.Queue()  # 初始化一个队列，后面存要返回给这个客户端的数据
        else:
            try :
                data = r.recv(1024)  # 注意这里是r，而不是conn，多个连接的情况
                print("收到数据",data)
                # r.send(data) # 不能直接发，如果客户端不收，数据就没了
                msg_dic[r].put(data)  # 往里面放数据
                outputs.append(r)  # 放入返回的连接队列里
            except ConnectionResetError as e:
                print("客户端断开了",r)
                if r in outputs:
                    outputs.remove(r) #清理已断开的连接
                inputs.remove(r) #清理已断开的连接
                del msg_dic[r] ##清理已断开的连接

    for w in writeable:  # 要返回给客户端的连接列表
        data_to_client = msg_dic[w].get()  # 在字典里取数据
        w.send(data_to_client)  # 返回给客户端
        outputs.remove(w)  # 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。

    for e in exceptional:  # 如果连接断开，删除连接相关数据
        if e in outputs:
            outputs.remove(e)
        inputs.remove(e)
        del msg_dic[e]


#*************************client
import socket
client = socket.socket()

client.connect(('localhost', 9000))

while True:
    cmd = input('>>> ').strip()
    if len(cmd) == 0 : continue
    client.send(cmd.encode('utf-8'))
    data = client.recv(1024)
    print(data.decode())

client.close()IO模型.txt----------------------------------------------------------------------------------------------------
IO模型前戏准备

在进行解释之前，首先要说明几个概念：

用户空间和内核空间
进程切换
进程的阻塞
文件描述符
缓存 I/O
用户空间与内核空间

现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。
操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。
为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。
针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

进程切换

为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换，这种切换是由操作系统来完成的。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。
从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：

保存处理机上下文，包括程序计数器和其他寄存器。

更新PCB信息。

把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。

选择另一个进程执行，并更新其PCB。

更新内存管理的数据结构。

恢复处理机上下文。
注：总而言之就是很耗资源的

进程的阻塞

正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。

文件描述符fd

文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。
文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。

缓存 I/O

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。用户空间没法直接访问内核空间的，内核态到用户态的数据拷贝

思考：为什么数据一定要先到内核区，直接到用户内存不是更直接吗？
缓存 I/O 的缺点：

数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。Javascript.txt----------------------------------------------------------------------------------------------------
JavaScript:
代码写在body的<script></script>里面。
定义变量时使用var x=，要是不加var，那么定义的变量为全局变量。

代码块不再用缩进表示包含，而是用{}。
例如 if（条件）{  }

定义函数function f（）{  }
执行函数function（）

null为空对象，typeof null -----object
列表、字典等统统称为对象object。

强制类型转换
parseInt() ----------整型
parseInt(12.121212) --------12
parseInt("hello") ------------NAN ---not a number
parseInt("123abc") ----------123
parseInt("abc123") -----------NAN

parseFloat() --------浮点型

i++：先输出后计算
++i：先计算后输出


-------------------------------------------------------------------------------------------------------------
ECMAScript等性运算符 ==
执行类型转换的规则如下：
如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。
如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。
如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。
如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。
在比较时，该运算符还遵守下列规则：
值 null 和 undefined 相等。
在检查相等性时，不能把 null 和 undefined 转换成其他值。
如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。
如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。
NAN只要参与比较，布尔值一定是false，除非！=，例如var n=NAN,  n==NAN ------false;  var n=123,  n!=NAN ------true。
2=="2" ------true，"2"会进行转换，==是不完全等。
2==="2" ----false，===是完全等。


-------------------------------------------------------------------------------------------------------------
ECMAScript 关系运算符< >
var bResult = "Blue" < "alpha";
alert(bResult); //输出 true　　
在上面的例子中，字符串 "Blue" 小于 "alpha"，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。

比较数字和字符串
另一种棘手的状况发生在比较两个字符串形式的数字时，比如：
var bResult = "25" < "3";
alert(bResult); //输出 "true"
上面这段代码比较的是字符串 "25" 和 "3"。两个运算数都是字符串，所以比较的是它们的字符代码（"2" 的字符代码是 50，"3" 的字符代码是 51）。

如果把某个运算数改为数字，那么结果就有趣了：
var bResult = "25" < 3;
alert(bResult); //输出 "false"
这里，字符串 "25" 将会被转换成数字 25，然后再与数字 3 进行比较。

总结：
比较运算符两侧如果一个是数字类型,一个是其他类型,会将其他类型转换成数字类型再进行比较。
比较运算符两侧如果都是字符串类型,比较的是最高位的asc码,如果最高位相等,继续取第二位进行比较。


-------------------------------------------------------------------------------------------------------------
判断语句：
switch（value）{
case value1：函数；break；-------------------判断value1是否等于value，相等的话执行后边的函数。如果不加break的话，函数将会继续往下执行，直到遇到break。
case value2：函数；break；
case value3：函数；break；
case value4：函数；break；
default：函数；---------------------------------如果所有value都不满足条件，就会执行default后面的函数。


-------------------------------------------------------------------------------------------------------------
for循环：
for（var i=0；i<10；i++）
{
	document.write("hello"-i-"<br>")
}

attr=[1,2,3]
for (i in attr)
{
	document.write(i) --------------0, 1, 2, 里面的i是attr里面元素的位置。
}


-------------------------------------------------------------------------------------------------------------
while循环：
while（条件）
{
	函数；
}


-------------------------------------------------------------------------------------------------------------
异常处理：
try {
    //这段代码从上往下运行，其中任何一个语句抛出异常该代码块就结束运行
       throw Error("define error")；---------主动抛出异常throw Error('xxxx')。
}
catch (e) {
    // 如果try代码块中抛出了异常，catch代码块中的代码就会被执行。
    //e是一个局部变量，用来指向Error对象或者其他抛出的对象
}
finally {
     //无论try中代码是否有异常抛出（甚至是try代码块中有return语句），finally代码块中始终会被执行。


-------------------------------------------------------------------------------------------------------------
11种内置对象
包括：
Array数组对象 , String字符串对象 , Date日期对象 ,  Math数学对象 ,  Boolean布尔值对象 ,  Number数字对象 ,  Function函数对象 ,  Global全局对象 ,  Error错误对象 ,  RegExp正则表达式对象 , Object自定义对象。
在JavaScript中除了null和undefined以外其他的数据类型都被定义成了对象，也可以用创建对象的方法定义变量，
String、Math、Array、Date、RegExp都是JavaScript中重要的内置对象，在JavaScript程序大多数功能都是通过对象实现的。

<script language="javascript">
var aa=Number.MAX_VALUE;
//利用数字对象获取可表示最大数
var bb=new String("hello JavaScript");
//创建字符串对象
var cc=new Date();
//创建日期对象
var dd=new Array("星期一","星期二","星期三","星期四");
//数组对象
</script>


-------------------------------------------------------------------------------------------------------------
字符串属性及方法：
str.length --------------字符串长度。

字符串编排方法：
var str="hello world";
alert(str.bold()); -----------<b>hello world</b> -----------返回粗体表示字符串。
alert(str.italics()); ----------<i>hello world</i>
alert(str.anchor()); ---------<a>hello world</a>

字符串大小写转换：
var str1="AbcdEfgh";
var str2=str1.toLowerCase();
var str3=str1.toUpperCase();
alert(str2);
//结果为"abcdefgh"
alert(str3);
//结果为"ABCDEFGH"

获取指定字符串：
书写格式
x.charAt(index)
x.charCodeAt(index)
使用注解
x代表字符串对象
index代表字符位置
index从0开始编号
charAt返回index位置的字符
charCodeAt返回index位置的Unicode编码

var str1="welcome to the world of JS! 苑昊";
var str2=str1.charAt(28);
var str3=str1.charCodeAt(28);
alert(str2);
//结果为"苑"
alert(str3);
//结果为33489


查询字符串：
x.indexOf(findstr,index)
x.lastIndexOf(findstr)

var str1="welcome to the world of JS!";
var str2=str1.indexOf("l"); -----------从左到右开始寻找，获取l的位置-------2
var str3=str1.lastIndexOf("l"); -------从右到左开始寻找，获取l的位置-------18

x.match(regexp)----------------------regexp为一段字符串，该函数相当于匹配x中的regexp，返回匹配字符串的数组，如果x中没有该字符串，返回一个null。
x.search(regexp)----------------------寻找字符串regexp在x中的位置。
//x代表字符串对象
//regexp代表正则表达式或字符串
//match返回匹配字符串的数组，如果没有匹配则返回null
//search返回匹配字符串的首字符位置索引

var str1="welcome to the world of JS!";
var str2=str1.match("world");
var str3=str1.search("world");
alert(str2[0]);
//结果为"world"
alert(str3);
//结果为15

截取子字符串：
//x.substr(start, length)
//x.substring(start, end)
//x代表字符串对象
//start表示开始位置
//length表示截取长度
//end是结束位置加1，比如end=3，那么取出的数据直到2为止。
//第一个字符位置为0

var str1="abcdefgh";
var str2=str1.substr(2,4);----------2为开始位置，4是长度。
var str3=str1.substring(2,4);--------2为开始位置，4是结束位置，但取出来的数据不包括4。
alert(str2);
//结果为"cdef"
alert(str3);
//结果为"cd"

//x.slice(start, end)
var str1="abcdefgh";
var str2=str1.slice(2,4);-----------2为开始位置，4为结束位置，不取4位置的数据。
var str3=str1.slice(4);-------------从4位置开始取，直到字符串结尾。
var str4=str1.slice(2,-1);
var str5=str1.slice(-3,-1);
alert(str2);
//结果为"cd"
alert(str3);
//结果为"efgh"
alert(str4);
//结果为"cdefg"
alert(str5);
//结果为"fg"

字符串替换：
//x.replace(findstr,tostr)
var str1="abcdefgh";
var str2=str1.replace("cd","aaa");
alert(str2);
//结果为"abaaaefgh"

分割字符串：
var str1="一,二,三,四,五,六,日";
var strArray=str1.split(",");
alert(strArray[1]);
//结果为"二"

连接字符串：
y=x.concat(addstr)
//x代表字符串对象
//addstr为添加字符串
//返回x+addstr字符串
var str1="abcd";
var str2=str1.concat("efgh");
alert(str2);
//结果为"abcdefgh"


-----------------------------------------------------------------------------------------------------------------
数组Array：
Array 对象用于在单个的变量中存储多个值。
语法:
创建方式1:
var a=[1,2,3];

创建方式2:
new Array();     //  创建数组时允许指定元素个数也可以不指定元素个数。
new Array(size);//if 1个参数且为数字,即代表size,not content
    初始化数组对象:
    var cnweek=new Array(7);
        cnweek[0]="星期日";
        cnweek[1]="星期一";
        ...
        cnweek[6]="星期六";

new Array(element0, element1, ..., elementn)//也可以直接在建立对象时初始化数组元素，元素类型允许不同
var test=new Array(100,"a",true);

创建二维数组：
var cnweek=new Array(7);
for (var i=0;i<=6;i++){
    cnweek[i]=new Array(2);
}
cnweek[0][0]="星期日";
cnweek[0][1]="Sunday";
cnweek[1][0]="星期一";
cnweek[1][1]="Monday";
...
cnweek[6][0]="星期六";
cnweek[6][1]="Saturday";


---------------------------------------------------------------------------------------------------------------------
Array对象的属性及方法：
Array.length------------------获取数组元素的个数。
toString----------------------无论是什么对象，都会返回该对象的原始字符串。

连接数组join：
x.join(bystr)
//x代表数组对象
//bystr作为连接数组中元素的字符串
//返回连接后的字符串
//与字符串的split功能刚好相反
var arr1=[1, 2, 3, 4, 5, 6, 7];
var str1=arr1.join("-");
alert(str1);
//结果为"1-2-3-4-5-6-7"

连接数组concat（给数组增加内容）：
str=[1,2,3]
str2=str.concat(4,5) -------------------------1,2,3,4,5



数组排序-reverse  sort：
x.reverse()
var arr1=[32, 12, 111, 444];
var arr1=["a","d","f","c"];
arr1.reverse(); --------------------------颠倒数组元素。
alert(arr1.toString());
//结果为444,111,12,32

arr1.sort(); -----------------------------排序数组元素。
alert(arr1.toString());
//结果为111,12,32,444 -----------------按最高位排序。

如果就想按着数字比较呢?
function intSort(a,b){
    if (a>b){
        return 1;//-1
    }
    else if(a<b){
        return -1;//1
    }
    else {
        return 0
    }
}
（该函数简写：function intSort(a,b) { return a-b }  ）
arr.sort(intSort); -------------------------在sort里面加上一个函数intSort，sort就会按照你定义的规则进行排序。



数组切片-slice：
//x.slice(start, end)
//x代表数组对象
//start表示开始位置索引
//end是结束位置下一数组元素索引编号
//第一个数组元素索引为0
//start、end可为负数，-1代表最后一个数组元素
//end省略则相当于从start位置截取以后所有数组元素

var arr1=['a','b','c','d','e','f','g','h'];
var arr2=arr1.slice(2,4);
var arr3=arr1.slice(4);
var arr4=arr1.slice(2,-1);

alert(arr2.toString());
//结果为"c,d"
alert(arr3.toString());
//结果为"e,f,g,h"
alert(arr4.toString());
//结果为"c,d,e,f,g"



删除子数组：
//x. splice(start, deleteCount, value, ...)
//x代表数组对象
//splice的主要用途是对数组指定位置进行删除和插入
//start表示开始位置索引
//deleteCount删除数组元素的个数
//value表示在删除位置插入的数组元素
//value参数可以省略

var a = [1,2,3,4,5,6,7,8];
a.splice(1,2);
//a变为 [1,4,5,6,7,8]
alert(a.toString());
a.splice(1,1);
 //a变为[1,5,6,7,8]
alert(a.toString());
a.splice(1,0,2,3);
 //a变为[1,2,3,5,6,7,8]
alert(a.toString());



数组的进出栈操作（1）：
//push pop这两个方法模拟的是一个栈操作

//x.push(value, ...)  压栈，在x的末尾位置放进数据。
//x.pop()                弹栈，在x的末尾位置取出数据。
//x代表数组对象
//value可以为字符串、数字、数组等任何值
//push是将value值添加到数组x的结尾
//pop是将数组x的最后一个元素删除

var arr1=[1,2,3];
arr1.push(4,5);
alert(arr1);
//结果为"1,2,3,4,5"
arr1.push([6,7]);
alert(arr1)
//结果为"1,2,3,4,5,6,7"
arr1.pop();
alert(arr1);
//结果为"1,2,3,4,5"



数组的进出栈操作（2）：
// unshift shift
//x.unshift(value,...)
//x.shift()
//x代表数组对象
//value可以为字符串、数字、数组等任何值
//unshift是将value值插入到数组x的开始
//shift是将数组x的第一个元素删除

var arr1=[1,2,3];
arr1.unshift(4,5);
alert(arr1);
//结果为"4,5,1,2,3"
arr1. unshift([6,7]);
alert(arr1);
//结果为"6,7,4,5,1,2,3"
arr1.shift();
alert(arr1);
//结果为"4,5,1,2,3"



Function对象：（注意：js的函数加载执行与python不同，它是整体加载完才会执行，所以执行函数放在函数声明上面或下面都可以）
函数的定义：
function 函数名 (参数)
{
    函数体;
    return 返回值;
}
1.可以使用变量、常量或表达式作为函数调用的参数。
2.函数由关键字function定义。
3.函数名的定义规则与标识符一致，大小写是敏感的。
4.返回值必须使用return。

function.length -------------------------------------------返回函数期望的参数个数。

Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。

void方法：
alert(void(fun1(1,2)))

function.
用 Function 类直接创建函数的语法如下：
function 函数名 (参数)
{
    函数体;
    return 返回值;
}
//another way:
var 函数名 = new Function("参数1","参数n","function_body");

函数的内置对象arguments：
无论函数传入多少参数，都会被argument记录下来，argument是一个Array对象。




匿名函数：执行函数必须放在匿名函数声明之前，因为此时的匿名函数相当于一个变量。
// 匿名函数
    var func = function(arg){
        return "tony";
    }

// 匿名函数的应用
    (function(){
        alert("tony");
    } )()

    (function(arg){
        console.log(arg);
    })('123')


-----------------------------------------------------------------------------------------------------------------------------------------
BOM对象：
BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。

window对象
    所有浏览器都支持 window 对象。
    概念上讲.一个html文档对应一个window对象。
    功能上讲: 控制浏览器窗口的。
    使用上讲: window对象不需要创建对象,直接使用即可。

window方法：
alert()            显示带有一段消息和一个确认按钮的警告框。
confirm()          显示带有一段消息以及确认按钮和取消按钮的对话框。----------------------------------确认时返回true，取消时返回false。
prompt()           显示可提示用户输入的对话框。---------------------------------------------------------让用户输入一段内容。
open("网址")             打开一个新的浏览器窗口或查找一个已命名的窗口。-------------------------------搜索输入的网址。
close()            关闭浏览器窗口。
setInterval(func，1000)      按照指定的周期（以毫秒计）来调用函数或计算表达式。-------------------func为需要执行的函数，1000为每隔1000毫秒后执行一次。一般在前面加上一个f=setInterval，这样的话才能使用clearInterval（f）关掉，且后面func不能带（），不然函数只会执行一次。
clearInterval()    取消由 setInterval() 设置的 timeout。-------------------------------------------------使用方法为clearInterval（f），f=setInterval。
setTimeout()       在指定的毫秒数后调用函数或计算表达式。
clearTimeout()     取消由 setTimeout() 方法设置的 timeout。
scrollTo()         把内容滚动到指定的坐标。


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Date对象的方法：
创建方法：
//方法1：不指定参数
var nowd1=new Date();
alert(nowd1.toLocaleString( ));
//方法2：参数为日期字符串
var nowd2=new Date("2004/3/20 11:12");
alert(nowd2.toLocaleString( ));
var nowd3=new Date("04/03/20 11:12");
alert(nowd3.toLocaleString( ));
//方法3：参数为毫秒数
var nowd3=new Date(5000);
alert(nowd3.toLocaleString( ));
alert(nowd3.toUTCString());

//方法4：参数为年月日小时分钟秒毫秒
var nowd4=new Date(2004,2,20,11,12,0,300);
alert(nowd4.toLocaleString( ));
//毫秒并不直接显示

获取日期和时间：
getDate()                 获取日
getDay ()                 获取星期
getMonth ()               获取月（0-11）
getFullYear ()            获取完整年份
getYear ()                获取年
getHours ()               获取小时
getMinutes ()             获取分钟
getSeconds ()             获取秒
getMilliseconds ()        获取毫秒
getTime ()                返回累计毫秒数(从1970/1/1午夜)
例子：
var date = new Date(); //没有填入任何参数那么就是当前时间
        //2. 获得当前年份
        var year = date.getFullYear();

设置日期和时间：
//setDate(day_of_month)       设置日
//setMonth (month)                 设置月
//setFullYear (year)               设置年
//setHours (hour)         设置小时
//setMinutes (minute)     设置分钟
//setSeconds (second)     设置秒
//setMillliseconds (ms)       设置毫秒(0-999)
//setTime (allms)     设置累计毫秒(从1970/1/1午夜)

var x=new Date();
x.setFullYear (1997);    //设置年1997
x.setMonth(7);        //设置月7
x.setDate(1);        //设置日1
x.setHours(5);        //设置小时5
x.setMinutes(12);    //设置分钟12
x.setSeconds(54);    //设置秒54
x.setMilliseconds(230);        //设置毫秒230
document.write(x.toLocaleString( )+"<br>");
//返回1997年8月1日5点12分54秒

x.setTime(870409430000); //设置累计毫秒数
document.write(x.toLocaleString( )+"<br>");
//返回1997年8月1日12点23分50秒

日期和时间的转换:
getTimezoneOffset():8个时区×15度×4分/度=480;
返回本地时间与GMT的时间差，以分钟为单位
toUTCString()
返回国际标准时间字符串
toLocalString()
返回本地格式时间字符串
Date.parse(x)
返回累计毫秒数(从1970/1/1午夜到本地时间)
Date.UTC(x)
返回累计毫秒数(从1970/1/1午夜到国际时间)


-------------------------------------------------------------------------------------------------------------
RegExp对象：
    // 在表单验证时使用该对象验证用户填入的字符串是否符合规则.
    //创建正则对象方式1  参数1 正则表达式  参数2 验证模式  g global / i 忽略大小写. //参数2一般填写g就可以，也有“gi”.
    // 用户名 首字母必须是英文, 除了第一位其他只能是英文数字和_ . 长度最短不能少于6位 最长不能超过12位
    //----------------------------创建方式1
    /* var reg1 = new RegExp("^[a-zA-Z][a-zA-Z0-9_]{5,11}$","g");
    //
    //验证字符串
    var str = "bc123";
    alert(reg1.test(str));// true

    //----------------------------创建方式2  /填写正则表达式/匹配模式;
    var reg2 = /^[a-zA-Z][a-zA-Z0-9_]{5,11}$/g;

    alert(reg2.test(str));// true
     */
    //-------------------------------正则对象的方法-------------------
        //test方法  ==>  测试一个字符串是否复合 正则规则. 返回值是true 和false.

    //-------------------------String 中与正则结合的4个方法------------------.
    // macth search split replace
    var str = "hello world";

    //alert(str.match(/o/g)); //查找字符串中 复合正则的 内容.
    //alert(str.search(/h/g));// 0  查找字符串中符合正则表达式的内容位置
    //alert(str.split(/o/g)); // 按照正则表达式对字符串进行切割. 返回数组;
    alert(str.replace(/o/g, "s")); // hells wsrld  对字符串按照正则进行替换.


---------------------------------------------------------------------------------------------------------------------------
Math对象:
    //该对象中的属性方法 和数学有关.
    //Math是内置对象 , 与Global的不同之处是, 在调用时 需要打出 "Math."前缀.
    //属性学习:
    //alert(Math.PI);
    //方法学习:
        //alert(Math.random()); // 获得随机数 0~1 不包括1.
        //alert(Math.round(1.5)); // 四舍五入
        //练习：获取1-100的随机整数，包括1和100
             //var num=Math.random();
            //num=num*10;
            //num=Math.round(num);
            // alert(num)
        //============max  min=========================
        /* alert(Math.max(1,2));// 2
        alert(Math.min(1,2));// 1 */
        //-------------pow--------------------------------
        alert(Math.pow(2,4));// pow 计算参数1 的参数2 次方.

abs(x)    返回数的绝对值。
exp(x)    返回 e 的指数。
floor(x)对数进行下舍入。
log(x)    返回数的自然对数（底为e）。
max(x,y)    返回 x 和 y 中的最高值。
min(x,y)    返回 x 和 y 中的最低值。
pow(x,y)    返回 x 的 y 次幂。
random()    返回 0 ~ 1 之间的随机数。
round(x)    把数四舍五入为最接近的整数。
sin(x)    返回数的正弦。
sqrt(x)    返回数的平方根。
tan(x)    返回角的正切。


-----------------------------------------------------------------------------------------------------------------------------
History对象：
History 对象包含用户（在浏览器窗口中）访问过的 URL。
History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。

length  返回浏览器历史列表中的 URL 数量。
back()    加载 history 列表中的前一个 URL。向后加载。
forward()    加载 history 列表中的下一个 URL。往前加载。
go()    加载 history 列表中的某个具体页面。go(1)往前加载，go(-1)退回前一个加载。
（相当于浏览器左上角的前进后退按钮）


-----------------------------------------------------------------------------------------------------------------------------
Location对象：Location 对象方法

location.assign(URL) -----------------------------加载URL，在本页面打开，区别于open，open打开的是一个新页面。
location.reload() ---------------------------------重新加载本页面，相当于refresh刷新。
location.replace(newURL)//注意与assign的区别
（例如你的页面是通过一个按钮click进来的，而且该按钮绑定的是assign函数，那么可以通过返回键回到原始带有click的界面，但如果是replace的话，打开的页面没有返回键，直接就是最开始的界面，即不能返回click键那一层）


-----------------------------------------------------------------------------------------------------------------------------
Dom对象：
访问 HTML 元素（节点）,访问 HTML 元素等同于访问节点,我们能够以不同的方式来访问 HTML 元素：
全局查找标签方法：
通过使用 getElementById() 方法
通过使用 getElementsByTagName() 方法  ------------------Elements，复数形式，得到的是一个集合，可以通过索引如Array[0]得到想要的标签。
通过使用 getElementsByClassName() 方法
通过使用 getElementsByName() 方法
局部调用：
getElementsByTagName()

自身属性：
通过ele.innerHTML可以获取该元素节点的文本。且可以更改文本的内容，ele.innerHTML="text"。
（与innerHTML相似的是innerText，innerHTML显示的是ele下的所有标签以及text，而innerText显示的是ele下的text，但不包括标签）
attributes - 节点（元素）的属性节点
nodeType - 节点类型
nodeValue - 节点值
nodeName - 节点名称

导航属性:
parentNode - 节点（元素）的父节点 (推荐)
firstChild - 节点下第一个子元素
lastChild - 节点下最后一个子元素
childNodes - 节点（元素）的子节点
推荐导航属性：
parentElement      ------------ 父节点标签元素
children                 ------------ 所有子标签
firstElementChild       --------- 第一个子标签元素
lastElementChild        --------- 最后一个子标签元素
nextElementtSibling      ------- 下一个兄弟标签元素
previousElementSibling  ------ 上一个兄弟标签元素

局部查找：
<div id="div1">
    <div class="div2">i am div2</div>
    <div name="yuan">i am div2</div>
    <div id="div3">i am div2</div>
    <p>hello p</p>
</div>

<script>
//   var div1=document.getElementById("div1");
////支持;
//   var ele= div1.getElementsByTagName("p");
//   alert(ele.length);
////支持
//   var ele2=div1.getElementsByClassName("div2");
//   alert(ele2.length);
////不支持
//   var ele3=div1.getElementById("div3");
//   alert(ele3.length);
////不支持
//   var ele4=div1.getElementsByName("yuan");
//   alert(ele4.length)
</script>

如果想找到你点击的这个标签，可以使用this，例如<p onclick="func（this）>"，点击后执行func函数，传进去一个参数this，this就是这个p标签，然后你可以在定义func的时候使用这个p标签。


-----------------------------------------------------------------------------------------------------------------------------
HTML DOM Event（事件）：
onclick        当用户点击某个对象时调用的事件句柄。
ondblclick     当用户双击某个对象时调用的事件句柄。
onfocus        元素获得焦点。               //练习：输入框
onblur         元素失去焦点。               应用场景：用于表单验证,用户离开某个输入框时,代表已经输入完了,我们可以对它进行验证.
onchange       域的内容被改变。             应用场景：通常用于表单元素,当元素内容被改变时触发.（三级联动）
onkeydown      某个键盘按键被按下。          应用场景: 当用户在最后一个输入框按下回车按键时,表单提交.
onkeypress     某个键盘按键被按下并松开。
onkeyup        某个键盘按键被松开。
onload         一张页面或一幅图像完成加载。将onload放在<body>标签里面，即<body onload="func">意思是body标签执行完成后（也就是页面加载完成时）立即执行func函数。
onmousedown    鼠标按钮被按下。
onmousemove    鼠标被移动。
onmouseout     鼠标从某元素移开。
onmouseover    鼠标移到某元素之上。
onmouseleave   鼠标从元素离开
onselect      文本被选中。
onsubmit      确认按钮被点击。是当表单在提交时触发. 该属性也只能给form元素使用.应用场景: 在表单提交前验证用户输入是否正确.如果验证失败.在该方法中我们应该阻止表单的提交.
（在form表单里面，当你点击submit之后，首先执行的是submit="func"里面的func函数，然后再执行提交操作，你可以在func函数里面加上判断，如果判断数据出现错误，不应该被提交时，加上一个return false，这样数据就不会被提交）

在函数后边加行一个参数，意思是将发生的event记录下来，放在传进去的参数里面，比如，func(e)，那么e就存储着信息。注意这个e不能写在标签里面，<p onclick="func(e)">里面的e是参数，不是事件对象e。事件对象e需写在script的function f（e）里面。
var ele=document.getElementsByClassName("inner")[0];
    ele.onclick=function (e) {
        alert("inner");
        e.stopPropagation() ----------------执行完本函数不再执行另外的函数，阻止向外传播。
    }


传播实例：
<div id="abc_1" style="border:1px solid red;width:300px;height:300px;">
        <div id="abc_2" style="border:1px solid red;width:200px;height:200px;">

        </div>
    </div>
    <script type="text/javascript">
    document.getElementById("abc_1").onclick=function(){
        alert('111');
    }
    document.getElementById("abc_2").onclick=function(event){
        alert('222');
        event.stopPropagation(); //阻止事件向外层div传播.
    }

</script>


------------------------------------------------------------------------------------------------------------------------------
通过script的标签增删改查：
function add() {
    var ele=document.createElement("p"); ----------------------------创建一个p标签。
    ele.innerHTML="hello p"; ------------------------------------------给p标签添加文本。innerHTML不但可以添加文本，还可以增加标签。innerText只能添加文本。
    var father=document.getElementsByClassName("div1")[0]; ------找到父级标签。
    father.appendChild(ele) --------------------------------------------通过父级标签添加子级p标签。
}
function del() {
    var father=document.getElementsByClassName("div1")[0];-------找到父级标签。
    var son=father.getElementsByTagName("p")[0];-------------------找到需要删除的子级标签。
    father.removeChild(son)---------------------------------------------删除子级标签。
}
function change() {
    var img=document.createElement("img");--------------------------创建一个img标签。
    img.src="scau.png";--------------------------------------------------给img标签增加内容。
    (上面这一步的另一种方法：img.setAttribute("src","scau.png"))
    var ele=document.getElementsByTagName("p")[0];-----------------找到被替换标签。
    var father=document.getElementsByClassName("div1")[0];---------找到父级标签
    father.replaceChild(img,ele)-------------------------------------------替换标签。
}
使用setAttribute();方法修改属性。
使用innerHTML属性修改元素的内容。

ele的style属性：
ele.style.color="red"
ele.style.fontSize="10px"

改变 HTML 属性
        elementNode.setAttribute(name,value)
        elementNode.getAttribute(name)<-------------->elementNode.value(DHTML)
创建新的 HTML 元素
        createElement(name)
删除已有的 HTML 元素
        elementNode.removeChild(node)
关于class的操作
        elementNode.className---------------------------输出类名，如果有多个类名，一同输出。
        elementNode.classList------------------------------以列表的形式输出类名。
        elementNode.classList.add（"name"）-------------增加类名。
        elementNode.classList.remove（"name"）---------删除类名。


----------------------------------------------------------------------------------------------------------------------------
jquery.txt----------------------------------------------------------------------------------------------------
jQuery：
虽然jQuery对象是包装DOM对象后产生的，但是jQuery无法使用DOM对象的任何方法，同理DOM对象也不能使用jQuery里的方法。
$variable[0]：jquery对象转为dom对象 -----------只需在jQuery对象后面加上[0]即可将该对象转换为dom对象，从而可以使用dom方法。
例如：下面两个方法的效果是一样的。
$("#msg").html();---------------使用jQuery方法获取html。
 $("#msg")[0].innerHTML;------先转换为dom对象再使用dom方法。

基础语法：$（selector）.action() ---------------selector选择器，action动作。

基本选择器
$("*")  $("#id")   $(".class")  $("element")  $(".class,p,div")

层级选择器
$(".outer div")-------outer子级所有的div标签。  $(".outer>div")-------outer第一子级div标签，如果第一子级不是div，将不起效果。  $(".outer+div")-----------找到outer下方相邻的div标签。  $(".outer~div")-----------找到outer下方同级的div标签，可以不相邻。

基本筛选器
$("li:first")--------li下第一个标签。   $("li:eq(2)") --------li下第二个标签。   $("li:even") -------li下所有的偶数（odd为奇数）。    $("li:gt(2)") -------- li下面第2个标签以下的标签（ li : lt(2) ，li第2个标签以上的标签）。

属性选择器
$('[id="div1"]')   $('["alex="sb"][id]') ------------多重限制的话可以这么写：（"[id="div1"]" "[class="div"]" ）

表单选择器
$("[type='text']")----->$(":text")         注意只适用于input标签  : $("input:checked")

还可以这么写：$（"div"）.eq（2）.css（color：red）

查找选择器
$(".outer").children("p").css("color","red") -----------找到outer的第一子级p。
$(".outer").find("p").css("color","red") ---------------找到outer的所有子级p标签。
 $(".test").next() --------------------------------------下一个标签。
$(".test").nextAll() ------------------------------------下面所有的标签。
$(".test").nextUntil(“#end”) ------------------------直到#end标签。
 $("div").prev() ----------------------------------------上一个标签。
$("div").prevAll() --------------------------------------上面所有标签。
$("div").prevUntil() ------------------------------------直到。
 $(".test").parent() -------------------------------------父级标签。
$(".test").parents() -------------------------------------一直往外找父级标签，直到最外层。
$(".test").parentUntil() --------------------------------直到。
 $("div").siblings() -------------------------------------毗邻，找到与自己相同等级的兄弟标签，且上下面的标签都会去查找。
（上面的until直到，都不包括“直到”那层）

过滤筛选器
$("li").eq(2) ---------找到li中位置为2的li。
$("li").first()
$("li").hasclass("test")
在jQuery中判断某个标签里面是否含有某class时可以使用 hasClass("classname")或者 is(".classname")。

------------------------------------------------------------------------------------------------------------------------------------------------
$("li").attr("test")------------------获取li标签里test对应的属性值，如果输入两个参数，表示进行赋值，第一个参数为name，第二个参数为value。
$("").removeAttr();
$("li").prop("test")------------------获取li标签里test对应的属性值。
$("").removeProp();
对于HTML元素本身就带有的固有属性，在处理时，使用prop方法。
//对于HTML元素我们自己自定义的DOM属性，在处理时，使用attr方法。
//像checkbox，radio和select这样的元素，选中属性对应“checked”和
“selected”，这些也属于固有属性，因此需要使用prop方法去操作才能获得正确的结果。
--------------------------CSS类
$("").addClass(class|fn)
$("").removeClass([class|fn])
--------------------------HTML代码/文本/值
$("").html([val|fn])-------括号里面没内容的话，获取标签里面所有的内容，有内容的话表示进行替换。
$("").text([val|fn]) -------括号里面没内容的话，获取标签里面所有的内容，有内容的话表示进行替换，且无论括号里面的内容是什么，都会被当成字符串进行替换。
$("").val([val|fn|arr])-----括号里面没内容的话，获取标签里面的value值，有内容的话表示进行替换。
---------------------------
$("").css({"color":"red"})-添加css属性。
---------------------------$.each遍历
方式一：
arr=[11,22,33]
    $.each(arr,function(x,y){
        console.log(x) -----------------------x为下标，即arr里面元素的位置。
        console.log(y) -----------------------y为arr里面的元素。
    })

方式二：
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
$("p").each(function () {
        console.log($(this))
    })

---------------------------------------------------------------------------------------------------------------------------------------------
创建一个标签对象
$("<p>")
（注意创建完标签后得用append添加到父级标签后面才能用）

内部插入
$("").append(content|fn)      -----
>$("p").append("<b>Hello</b>");往p标签里面添加b标签。

$("").appendTo(content)       ----->$("p").appendTo("div");将p标签添加到div标签里面。

$("").prepend(content|fn)     -----
>$("p").prepend("<b>Hello</b>");往p标签里面添加b标签，且内容将会添加到最前面。

$("").prependTo(content)      ----->$("p").prependTo("#foo");将p标签添加到foo里面，且内容将会添加到最前面。

外部插入
$("").after(content|fn)       -----
>$("p").after("<b>Hello</b>");在p标签下面添加b标签。

$("").before(content|fn)      -----
>$("p").before("<b>Hello</b>");在p标签上面添加b标签。

$("").insertAfter(content)    ----->$("p").insertAfter("#foo");将p标签添加到foo标签的下面。

$("").insertBefore(content)   ----->$("p").insertBefore("#foo");将p标签添加到foo标签的上面。

//替换
$("").replaceWith(content|fn) ----->$("p").replaceWith("<b>Paragraph. </b>");

//删除
    $("").empty()----------清空内部内容，不会删除标签。
    $("").remove([expr])---删除标签。（可不填里面的参数）

//复制
    $("").clone([Even[,deepEven]])

---------------------------------------------------------------------------------------------------------------------------------------
CSS
        $("").css(name|pro|[,val|fn])
    位置
        $("").offset([coordinates])相对于视口的偏移量。
（返回或设置偏移量，设置的时候可以这样写offset({top:100,left:100}）,默认为像素px)
        $("").position()相对于已经定位的父标签的偏移量。
        $("").scrollTop([val])无参数时返回滚轮的位置，输入参数时设置滚轮的垂直位置。（一般这样用，$(window).scrollTop(0)----返回顶部）
        $("").scrollLeft([val])

拖动滚动条时触发函数：
window.onscroll=function () {
    console.log($(window).scrollTop()----每拉动一段距离打印一次滚动条位置)
}

内容溢出时的滚动条：
在style里面设置overflow：auto、hidden、scroll、inherit、visible
visible	默认值。内容不会被修剪，会呈现在元素框之外。
hidden	内容会被修剪，并且其余内容是不可见的。
scroll	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
auto	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
inherit	规定应该从父元素继承 overflow 属性的值。
（当你需要设置一个带滑轮的小窗口时，就可以加上overflow，且此时设置返回顶部等属性时，不再是使用window，而是用本小窗口对应的标签，即$(".div").scrollTop(0)）

    尺寸
        $("").height([val|fn])
        $("").width([val|fn])
        $("").innerHeight()
        $("").innerWidth()
        $("").outerHeight([soptions])
        $("").outerWidth([options])

----------------------------------------------------------------------------------------------------------------------------------------------
绑定函数：
$("").bind("click",function)----------绑定点击事件。
简写形式$("").click(function)

解除绑定.
$("").unbind("click")

(但是以上绑定函数会有个问题，例如你给ul下的li标签绑定了一个函数，当你新建一个新的li标签时，新的标签不会绑定这个函数，例如$("ul li").click(function)，给ul下的li绑定函数function，后面添加的li标签不会绑定这个函数，相当于只认最开始的li)

解决办法：使用事件委托on
$("ul").on("click","li",function) ----------------相当于主语变成了ul，然后将绑定事件委托给ul下面的li，也就是说，每次点击都会先找到ul，然后给ul下面所有的li绑定委托事件。

---------------------------------------------------------------------------------------------------------------------------------------
$(document).ready(function(){
              代码 -----------------------------等整个代码块加载完成后才去执行该代码。
})
（上述方法类似于onload）

简写方式：$(function(){
              代码
})

页面载入
    ready(fn)  //当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。
    $(document).ready(function(){}) -----------> $(function(){})

事件处理
    $("").on(eve,[selector],[data],fn)  // 在选择元素上绑定一个或多个事件的事件处理函数。

    //  .on的selector参数是筛选出调用.on方法的dom元素的指定子元素，如：
    //  $('ul').on('click', 'li', function(){console.log('click');})就是筛选出ul下的li给其绑定
    //  click事件；

    [selector]参数的好处:
        好处在于.on方法为动态添加的元素也能绑上指定事件；如：

        //$('ul li').on('click', function(){console.log('click');})的绑定方式和
        //$('ul li').bind('click', function(){console.log('click');})一样；我通过js给ul添加了一个
        //li：$('ul').append('<li>js new li<li>')；这个新加的li是不会被绑上click事件的

        //但是用$('ul').on('click', 'li', function(){console.log('click');}方式绑定，然后动态添加
        //li:$('ul').append('<li>js new li<li>');这个新生成的li被绑上了click事件

    [data]参数的调用:
             function myHandler(event) {
                alert(event.data.foo);
                }
             $("li").on("click", {foo: "bar"}, myHandler)

----------------------------------------------------------------------------------------------------------------------------------------
动画效果：

显示/隐藏：
$("").hide(1000)----里面的1000指的是在1000ms内慢慢隐藏。
$("").show(1000)
$("").toggle(1000)----切换，相当于集成了上面两个函数的功能，当hide时切换成show，当show时切换成hide。
滑进/滑出:
$("").slideDown(1000)
$("").slideup(1000)
$("").slideToggle(1000)
淡入/淡出:
fadeIn，fadeOut，fadeToggle，fadeTo（1000，0.6）---fadeTo两个参数，第一个是淡化时间，第二个是不透明度。
回调函数：前面函数执行完成之后会执行的函数。
例如：$("").show(1000，function())--------后面的function就是回调函数，当执行完成show之后便会执行unction函数。

------------------------------------------------------------------------------------------------------------------------------------------
扩展方法，插件：
$.extend(object)      //为JQuery 添加一个静态方法。
例子：
$.extend({xixi:function () {
   alert("youyou")
}});
    $.xixi()


$.fn.extend(object)   //为JQuery实例添加一个方法。
例子：
$.fn.extend({good:function () {
    alert("xixix")
}});
    $("div").good()

------------------------------------------------------------------------------------------------------------------------------------------
mouseover，mouseenter，mouseout，mouseleave，鼠标悬浮事件：
mouseover 事件在鼠标指针进入被选元素或任意子元素时都会被触发。
mouseenter 事件在鼠标指针进入被选元素时被触发。
mouseout 事件在鼠标指针离开被选元素或任意子元素时都会被触发。
mouseleave 事件只有在鼠标指针离开被选元素时被触发。

------------------------------------------------------------------------------------------------------------------------------------------
index() 方法返回指定元素相对于其他指定元素的 index 位置。
stop()   停止前面一切的动作并执行后面的操作。（例如轮播图，当你快速地在各个图片上划过时，产生的fadeIn和fadeOut延迟可以通过stop来消除掉）
hover(function1,function2) 鼠标悬浮的时候触发function1，鼠标离开时触发function2。MySQL.txt----------------------------------------------------------------------------------------------------
MySQL：
（博客园网址：https://www.cnblogs.com/yuanchenqi/articles/6357507.html）
语言特点：1.不区分大小写。2.每次语句结束时要加上结束符；。

sql及其规范：--------------------------------------------------------------------------------------------------------------
sql是Structured Query Language(结构化查询语言)的缩写。SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。

在使用它时，只需要发出“做什么”的命令，“怎么做”是不用使用者考虑的。SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的数据库均支持sql。

<1> 在数据库系统中，SQL语句不区分大小写(建议用大写) 。但字符串常量区分大小写。建议命令大写，表名库名小写；

<2> SQL语句可单行或多行书写，以“;”结尾。关键词不能跨多行或简写。

<3> 用空格和缩进来提高语句的可读性。子句通常位于独立行，便于编辑，提高可读性。
例如：
SELECT * FROM tb_table
            WHERE NAME="YUAN";

<4> 注释：单行注释：--

               多行注释：/*......*/

<5>sql语句可以折行操作

<6> DDL,DML和DCL（sql语言三大主要部分，定义语言，操作语言，控制语言）

常用语句：-----------------------------------------------------------------------------------------------------------------
--
-- 启动mysql服务与停止mysql服务命令：
--
-- net start mysql
-- net stop  mysql
--
--
-- 登陆与退出命令：
--
--    mysql －h 服务器IP -P 端口号 -u  用户名 -p 密码 －－prompt 命令提示符  －－delimiter 指定分隔符
--    mysql －h 127.0.0.1 -P 3306 -uroot -p123
--    quit------exit----\q;
--
--
-- \s;   ------my.ini文件：[mysql] default-character-set=gbk [mysqld] character-set-server=gbk
--
-- prompt 命令提示符（\D:当前日期 \d:当前数据库  \u:当前用户）
--
-- \T(开始日志) \t(结束日志)
--
-- show warnings;
--
-- help() ? \h
--
-- \G；
--
-- select now();---------打印当前时间。
-- select version();
-- select user;
--
-- \c 取消命令
--
-- delimiter 指定分隔符

数据库操作DDL---------------------------------------------------------------------------------------------------------------------------
-- 1.创建数据库（在磁盘上创建一个对应的文件夹）
    create database [if not exists] db_name [character set xxx]  --------------create database if not exists shuju character set gbk。[ ]里面的内容表示有的话就不创建，没有的话才会创建，并且以gbk格式编码（默认utf8）。
-- 2.查看数据库
    show databases;查看所有数据库
    show create database db_name; 查看数据库的创建方式

-- 3.修改数据库
    alter database db_name [character set xxx]

-- 4.删除数据库
    drop database [if exists] db_name;

-- 5.使用数据库
    切换数据库 use db_name; -- 注意：进入到某个数据库后没办法再退回之前状态，但可以通过use进行切换。
    查看当前使用的数据库 select database();

-- 6.将某个数据库的编码修改
    alter database s1 character set utf8；

mysql数据类型----------------------------------------------------------------------------------------------------------------------------
MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。

主键：用于标识每一行的字段，比如第一行你可以用1去标识，第二行用2去标识。（当然你可以使用任何符号作为主键去标识每一行，但记得，主键非空且唯一，即每一行的主键都不相同）

float（num1，num2）---定义一个浮点型数据，num1表示数字的个数，num2表示小数的个数，比如float（4，2）可以表示的最大的数为99.99。（如果超出范围的话，数据将无效）

char（3）-----定长，存储三个字节的字符串，必须是三个字节。

varchar（20）--非定长，最多存储20个字节的字符串。（varchar用的最多，但char的效率比较高，因为知道字符串的长度便可以直接获取数据）

基础操作--------------------------------------------------------------------------------------------------------------------------------
-- 1.创建表（类似于一个excel表）

        create table tab_name(
            field1 type[完整性约束条件],
            field2 type,
            ...
            fieldn type
        )[character set xxx];

         -- 创建一个员工表employee

         create table employee(
            id int primary key auto_increment ,
            name varchar(20),
            gender bit default 1,   -- gender char(1)  default 1   -----    或者 TINYINT(1)
            birthday date,
            entry_date date,
            job varchar(20),
            salary double(4,2) unsigned,
            resume text    -- 注意，这里作为最后一个字段不加逗号
          );


    /* 约束:
       primary key (非空且唯一)  :能够唯一区分出当前记录的字段称为主键！
       unique
       not null
       auto_increment 主键字段必须是数字类型。
       外键约束 foreign key  */    例如：alter table qq add charger int, add foreign key (charger) references qq(id);将charger作为外键与qq的id绑定起来，当你需要删除某id的行时，你必须先把对应该id的外键的行删除，否者无法删除。注意：外键和关联主键的数据类型要一致。
       创建的外键有个默认的名字“表名_ibfk_1”，可以通过constraint 键名     来给外键修改名字。
-- 2.查看表信息
    desc tab_name 查看表结构
    show columns from tab_name  查看表结构
    show tables 查看当前数据库中的所有的表
    show create table tab_name    查看当前数据库表建表语句

-- 3.修改表结构
   -- (1)增加列(字段)
      alter table tab_name add [column] 列名 类型［完整性约束条件］［first｜after 字段名］;
      alter table user add addr varchar(20) not null unique first/after username;
      #添加多个字段
      alter table users2
            add addr varchar(20),
            add age  int first,
            add birth varchar(20) after name;

   -- (2)修改一列类型
      alter table tab_name modify 列名 类型 [完整性约束条件]［first｜after 字段名］;（first表示将该列放到第一列，after 字段名--表示将该列放置到某字段后面）
      alter table users2 modify age tinyint default 20;
      alter table users2 modify age int  after id;

   -- (3)修改列名
      alter table tab_name change [column] 列名 新列名 类型 [完整性约束条件]［first｜after 字段名］;
      alter table users2 change age Age int default 28 first;------（default 28---默认值为28）

   -- (4)删除一列
      alter table tab_name drop [column] 列名;
      -- 思考：删除多列呢？删一个填一个呢？
      alter table users2
            add salary float(6,2) unsigned not null after name,
            drop addr;

   -- (5)修改表名
      rename table 表名 to 新表名;
   -- (6)修该表所用的字符集
      alter table student character set utf8;

-- 4.删除表
    drop table tab_name;

---5 添加主键，删除主键
    alter table tab_name add primary key(字段名称,...)
    alter table users drop primary key;

    eg:
    mysql> create table test5(num int auto_increment);
    ERROR 1075 (42000): Incorrect table definition; there can be only one auto column and it must be defined as a key
    create table test(num int primary key auto_increment);
    -- 思考，如何删除主键？
    alter table test modify id int;   -- auto_increment没了，但这样写主键依然存在，所以还要加上下面这句
    alter table test drop primary key;-- 仅仅用这句也无法直接删除主键

添加索引：
    -- 唯一索引
    alter table tab_name add unique [ index | key ] 字段名

    alter table users add unique(name)-- 索引值默认为字段名
    alter table users add unique key user_name(name);-- 索引值为user_name

    -- 添加联合索引
    alter table users add unique index name_age(name,age);#show create table users; --索引值为name_age

    -- 删除唯一索引
    alter table tab_name drop {index|key} index_name

（index普通索引，unique index唯一索引，fulltext index全文索引，）------唯一索引的字段不能重复。

create index index_emp_name on emp1(name);----------------为表emp1里的name字段创建索引，索引名称（索引值）为index_emp_name。该索引为普通索引。

--创建文章表
create table article(
            id int primary key auto_increment ,
            title varchar(20),
            publish_date INT,
            click_num INT,
            is_top TINYINT(1),
            content TEXT
          );

--完整性约束条件之主键约束
单字段主键
主键字段特点：非空且唯一
 create table users(
            id INT primary key,
            name varchar(20),
            city varchar(20)
          );

多字段联合主键
 create table users2(
            id INT,
            name varchar(20),
            city varchar(20),
            primary key(name,id)
          );

复制一个表：
1 复制 employee 表 => employee2
2 (1) create table employee2  like employee
3 (2) insert into employee2 select * from employee;




表纪录操作=================================================================================================
-- 1.增加一条记录insert

      /*insert ［into］ tab_name (field1,filed2,.......) values (value1,value2,.......);*/


      create table employee_new(
                 id int primary key auto_increment,
                 name varchar(20) not null unique,
                 birthday varchar(20),
                 salary float(7,2)
                             );

       insert into employee_new (id,name,birthday,salary) values
                     (1,'yuan','1990-09-09',9000);

       insert into employee_new values
       (2,'alex','1989-08-08',3000);

       insert into employee_new (name,salary) values
       ('xialv',1000);

      -- 插入多条数据
       insert into employee_new values
       (4,'alvin1','1993-04-20',3000),
       (5,'alvin2','1995-05-12',5000);

      -- set插入: insert ［into］ tab_name set 字段名=值

      insert into employee_new set id=12,name="alvin3";


-- 2.修改表记录  update tab_name set field1=value1,field2=value2,......[where 语句]（where语句可以用and来添加多个查找条件，例如where id=10 and city="haha"）

    /*      UPDATE语法可以用新值更新原有表行中的各列。
            SET子句指示要修改哪些列和要给予哪些值。
            WHERE子句指定应更新哪些行。如没有WHERE子句，则更新所有的行。*/

    update employee_new set birthday="1989-10-24" WHERE id=1;

    --- 将yuan的薪水在原有基础上增加1000元。
    update employee_new set salary=salary+4000 where name='yuan';

-- 3.删除表纪录

     delete from tab_name [where ....]

        /*    如果不跟where语句则删除整张表中的数据
            delete只能用来删除一行记录
            delete语句只能删除表中的内容，不能删除表本身，想要删除表，用drop
            TRUNCATE TABLE也可以删除表中的所有数据，词语句首先摧毁表，再新建表。此种方式删除的数据不能在
            事务中恢复。*/

                -- 删除表中名称为’alex’的记录。
                delete from employee_new where name='alex';
                -- 删除表中所有记录。
                delete from employee_new;-- 注意auto_increment没有被重置:alter table employee auto_increment=1;
                -- 使用truncate删除表中记录。
                truncate table emp_new;

-- 4.查看表内容

      select * from tab_name

-- 查询表达式

   SELECT *|field1,filed2 ...   FROM tab_name
                  WHERE 条件
                  GROUP BY field
                  HAVING 筛选
                  ORDER BY field
                  LIMIT 限制条数


 ---准备表

   CREATE TABLE ExamResult(

   id INT PRIMARY KEY  auto_increment,
   name VARCHAR (20),
   JS DOUBLE ,
   Django DOUBLE ,
   OpenStack DOUBLE
);


INSERT INTO ExamResult VALUES  (1,"yuan",98,98,98),
                               (2,"xialv",35,98,67),
                               (3,"alex",59,59,62),
                               (4,"wusir",88,89,82),
                               (5,"alvin",88,98,67),
                               (6,"yuan",86,100,55);


-- （1）select [distinct] *|field1，field2，......   from tab_name
            -- 其中from指定从哪张表筛选，*表示查找所有列，也可以指定一个列
            -- 表明确指定要查找的列，distinct用来剔除重复行。

                    -- 查询表中所有学生的信息。
                    select * from ExamResult;
                    -- 查询表中所有学生的姓名和对应的英语成绩。
                    select name,JS from ExamResult;
                    -- 过滤表中重复数据。
                    select distinct JS ,name from ExamResult;



-- （2）select 也可以使用表达式，并且可以使用: 字段 as 别名或者:字段 别名

                -- 在所有学生分数上加10分特长分显示。

                select name,JS+10,Django+10,OpenStack+10 from ExamResult;
                -- 统计每个学生的总分。
                select name,JS+Django+OpenStack from ExamResult;
                -- 使用别名表示学生总分。
                select name as 姓名,JS+Django+OpenStack as 总成绩 from ExamResult;
                select name,JS+Django+OpenStack 总成绩 from ExamResult;

                select name JS from ExamResult; -- what will happen?---->记得加逗号

-- （3）使用where子句，进行过滤查询。

            -- 查询姓名为XXX的学生成绩
            select * from ExamResult where name='yuan';
            -- 查询英语成绩大于90分的同学
            select id,name,JS from ExamResult where JS>90;
            -- 查询总分大于200分的所有同学
            select name,JS+Django+OpenStack as 总成绩 from
                        ExamResult where JS+Django+OpenStack>200 ;
            -- where字句中可以使用：
                     -- 比较运算符：
                        > < >= <= <> !=
                        between 80 and 100 值在10到20之间
                        in(80,90,100) 值是80或90或100
                        like 'yuan%'-----------可以匹配yuanhao、yuanyuan、yuang
                        /*
                        pattern可以是%或者_，
                        如果是%则表示任意多字符，此例如唐僧,唐国强
                        如果是_则表示一个字符唐_，只有唐僧符合。两个_则表示两个字符：__
                        */

                    -- 逻辑运算符
                        在多个条件直接可以使用逻辑运算符 and or not
            -- 练习
                -- 查询JS分数在 70－100之间的同学。
                select name ,JS from ExamResult where JS between 80 and 100;
                -- 查询Django分数为75,76,77的同学。
                select name ,Django from ExamResult where Django in (75,98,77);
                -- 查询所有姓王的学生成绩。
                select * from ExamResult where name like '王%';
                -- 查询JS分>90，Django分>90的同学。
                select id,name from ExamResult where JS>90 and Django >90;
                -- 查找缺考数学的学生的姓名
                select name from ExamResult where Database is null;


-- （4）Order by 指定排序的列，排序的列即可是表中的列名，也可以是select 语句后指定的别名。

              -- select *|field1,field2... from tab_name order by field [Asc|Desc]

              -- Asc 升序、Desc 降序，其中asc为默认值 ORDER BY 子句应位于SELECT语句的结尾。
              -- 练习：
              -- 对JS成绩排序后输出。
              select * from ExamResult order by JS;
              -- 对总分排序按从高到低的顺序输出
              select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0))
                   总成绩 from ExamResult order by 总成绩 desc;
              -- 对姓李的学生成绩排序输出
              select name ,(ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))
                   总成绩 from ExamResult where name like 'a%'
                                         order by 总成绩 desc;


-- （5）group by 分组查询：
        CREATE TABLE order_menu(
             id INT PRIMARY KEY auto_increment,
             product_name VARCHAR (20),
             price FLOAT(6,2),
             born_date DATE,
             class VARCHAR (20)
                                );


         INSERT INTO order_menu (product_name,price,born_date,class) VALUES
                                             ("苹果",20,20170612,"水果"),
                                             ("香蕉",80,20170602,"水果"),
                                             ("水壶",120,20170612,"电器"),
                                             ("被罩",70,20170612,"床上用品"),
                                             ("音响",420,20170612,"电器"),
                                             ("床单",55,20170612,"床上用品"),
                                             ("草莓",34,20170612,"水果");


            -- 注意,按分组条件分组后每一组只会显示第一条记录

            -- group by字句，其后可以接多个列名，也可以跟having子句,对group by 的结果进行筛选。


                    -- 按位置字段筛选
                       select * from order_menu group by 5;

                    -- 练习：对购物表按类名分组后显示每一组商品的价格总和
                       select class,SUM(price)from order_menu group by class;

                    -- 练习：对购物表按类名分组后显示每一组商品价格总和超过150的商品
                       select class,SUM(price)from order_menu group by class----------（sum，求各组的和）
                                                        HAVING SUM(price)>150;



                   /*
                   having 和 where两者都可以对查询结果进行进一步的过滤，差别有：
                     <1>where语句只能用在分组之前的筛选，having可以用在分组之后的筛选；
                     <2>使用where语句的地方都可以用having进行替换
                     <3>having中可以用聚合函数，where中就不行。
                   */


            -- GROUP_CONCAT() 函数
            SELECT id,GROUP_CONCAT(name),GROUP_CONCAT(JS) from ExamResult GROUP BY id;


-- （6）聚合函数： 先不要管聚合函数要干嘛，先把要求的内容查出来再包上聚合函数即可。
                 --   (一般和分组查询配合使用)

        --<1> 统计表中所有记录

            -- COUNT(列名)：统计行的个数
                    -- 统计一个班级共有多少学生？先查出所有的学生，再用count包上
                     select count(*) from ExamResult;
                    -- 统计JS成绩大于70的学生有多少个？
                     select count(JS) from ExamResult where JS>70;
                    -- 统计总分大于280的人数有多少？
                     select count(name) from ExamResult
                           where (ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0))>280;
                    -- 注意:count(*)统计所有行;     count(字段)不统计null值.

            -- SUM(列名)：统计满足条件的行的内容和
                    -- 统计一个班级JS总成绩？先查出所有的JS成绩，再用sum包上
                        select JS as JS总成绩 from ExamResult;
                        select sum(JS) as JS总成绩 from ExamResult;
                    -- 统计一个班级各科分别的总成绩
                        select sum(JS) as JS总成绩,
                               sum(Django) as Django总成绩,
                               sum(OpenStack) as OpenStack from ExamResult;

                    -- 统计一个班级各科的成绩总和
                        select sum(ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0))
                                                    as 总成绩 from ExamResult;
                    -- 统计一个班级JS成绩平均分
                        select sum(JS)/count(*) from ExamResult ;
                    -- 注意：sum仅对数值起作用，否则会报错。

            -- AVG(列名)：
                            -- 求一个班级JS平均分？先查出所有的JS分，然后用avg包上。
                                select avg(ifnull(JS,0)) from ExamResult;
                            -- 求一个班级总分平均分
                                select avg((ifnull(JS,0)+ifnull(Django,0)+ifnull(Database,0)))
                                                         from ExamResult ;
            -- Max、Min
                            -- 求班级最高分和最低分（数值范围在统计中特别有用）
                              select Max((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0)))
                              最高分 from ExamResult;
                              select Min((ifnull(JS,0)+ifnull(Django,0)+ifnull(OpenStack,0)))
                              最低分 from ExamResult;
                            -- 求购物表中单价最高的商品名称及价格
                              ---SELECT id, MAX(price) FROM order_menu;--id和最高价商品是一个商品吗?

                              SELECT MAX(price) FROM order_menu;

                            -- 注意：null 和所有的数计算都是null，所以需要用ifnull将null转换为0！
                            --      -----ifnull(JS,0)----------（JS列为null时，把null当作0 来处理）


                -- with rollup的使用

            --<2> 统计分组后的组记录


-- （7） 重点：Select from where group by having order by
                -- Mysql在执行sql语句时的执行顺序：
                -- from  where  select group by  having order by
                -- 分析:
                select JS as JS成绩 from ExamResult where JS成绩 >70; ---- 不成功
                select JS as JS成绩 from ExamResult having JS成绩 >90; --- 成功

--  (8) limit
                SELECT * from ExamResult limit 5;----显示5条纪录
                SELECT * from ExamResult limit 2,5;--跳过前两条显示接下来的五条纪录
                SELECT * from ExamResult limit 2,2;--跳过前两条纪录显示下面两条纪录


--- (9) 使用正则表达式查询
        SELECT * FROM employee WHERE emp_name REGEXP '^yu';  --匹配emp_name里面以yu开头的行

        SELECT * FROM employee WHERE emp_name REGEXP 'yun$'; --匹配emp_name里面以yun结尾的行

        SELECT * FROM employee WHERE emp_name REGEXP 'm{2}';  --匹配emp_name里面有两个m的行






外键约束================================================================================================================
---  每一个班主任会对应多个学生 , 而每个学生只能对应一个班主任

----主表

CREATE TABLE ClassCharger(

       id TINYINT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       age INT ,
       is_marriged boolean  -- show create table ClassCharger: tinyint(1)

);

INSERT INTO ClassCharger (name,age,is_marriged) VALUES ("冰冰",12,0),
                                                       ("丹丹",14,0),
                                                       ("歪歪",22,0),
                                                       ("姗姗",20,0),
                                                       ("小雨",21,0);


----子表

CREATE TABLE Student(

       id INT PRIMARY KEY auto_increment,
       name VARCHAR (20),
       charger_id TINYINT,     --切记:作为外键一定要和关联主键的数据类型保持一致
       -- [ADD CONSTRAINT charger_fk_stu]FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)

) ENGINE=INNODB;

INSERT INTO Student(name,charger_id) VALUES ("alvin1",2),
                                            ("alvin2",4),
                                            ("alvin3",1),
                                            ("alvin4",3),
                                            ("alvin5",1),
                                            ("alvin6",3),
                                            ("alvin7",2);


DELETE FROM ClassCharger WHERE name="冰冰";
INSERT student (name,charger_id) VALUES ("yuan",1);
-- 删除居然成功,可是 alvin3显示还是有班主任id=1的冰冰的;

-----------增加外键和删除外键---------

ALTER TABLE student  ADD CONSTRAINT abc
                     FOREIGN KEY(charger_id)
                     REFERENCES  classcharger(id);


ALTER TABLE student DROP FOREIGN KEY abc;

--外键约束对子表的含义:   如果在父表中找不到候选键,则不允许在子表上进行insert/update

--外键约束对父表的含义:    在父表上进行update/delete以更新或删除在子表中有一条或多条对
                    -- 应匹配行的候选键时,父表的行为取决于：在定义子表的外键时指定的
                    -- on update/on delete子句


-----------------innodb支持的四种方式---------------------------------------

-----cascade方式 在父表上update/delete记录时，同步update/delete掉子表的匹配记录
-----外键的级联删除：如果父表中的记录被删除，则子表中对应的记录自动被删除--------

     FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)
                              ON DELETE CASCADE


------set null方式 在父表上update/delete记录时，将子表上匹配记录的列设为null
   -- 要注意子表的外键列不能为not null

     FOREIGN KEY (charger_id) REFERENCES ClassCharger(id)
                              ON DELETE SET NULL


------Restrict方式 :拒绝对父表进行删除更新操作(了解)

------No action方式 在mysql中同Restrict,如果子表中有匹配的记录,则不允许对父表对应候选键
   -- 进行update/delete操作（了解）



多表查询=========================================================
准备表

-- 准备两张表
-- company.employee
-- company.department

      create table employee(
      emp_id int auto_increment primary key not null,
      emp_name varchar(50),
      age int,
      dept_id int
      );

      insert into employee(emp_name,age,dept_id) values
        ('A',19,200),
        ('B',26,201),
        ('C',30,201),
        ('D',24,202),
        ('E',20,200),
        ('F',38,204);


    create table department(
       dept_id int,
       dept_name varchar(100)
      );

    insert into department values
      (200,'人事部'),
      (201,'技术部'),
      (202,'销售部'),
      (203,'财政部');

mysql> select * from employee;
+--------+----------+------+---------+
| emp_id | emp_name | age  | dept_id |
+--------+----------+------+---------+
|      1 | A        |   19 |     200 |
|      2 | B        |   26 |     201 |
|      3 | C        |   30 |     201 |
|      4 | D        |   24 |     202 |
|      5 | E        |   20 |     200 |
|      6 | F        |   38 |     204 |
+--------+----------+------+---------+
rows in set (0.00 sec)

mysql> select * from department;
+---------+-----------+
| dept_id | dept_name |
+---------+-----------+
|     200 | 人事部    |
|     201 | 技术部    |
|     202 | 销售部    |
|     203 | 财政部    |
+---------+-----------+
rows in set (0.01 sec)


多表查询之连接查询==================================================
1.笛卡尔积查询
mysql> SELECT * FROM employee,department;

--        select employee.emp_id,employee.emp_name,employee.age,
--        department.dept_name from employee,department;

+--------+----------+------+---------+---------+-----------+
| emp_id | emp_name | age  | dept_id | dept_id | dept_name |
+--------+----------+------+---------+---------+-----------+
|      1 | A        |   19 |     200 |     200 | 人事部    |
|      1 | A        |   19 |     200 |     201 | 技术部    |
|      1 | A        |   19 |     200 |     202 | 销售部    |
|      1 | A        |   19 |     200 |     203 | 财政部    |
|      2 | B        |   26 |     201 |     200 | 人事部    |
|      2 | B        |   26 |     201 |     201 | 技术部    |
|      2 | B        |   26 |     201 |     202 | 销售部    |
|      2 | B        |   26 |     201 |     203 | 财政部    |
|      3 | C        |   30 |     201 |     200 | 人事部    |
|      3 | C        |   30 |     201 |     201 | 技术部    |
|      3 | C        |   30 |     201 |     202 | 销售部    |
|      3 | C        |   30 |     201 |     203 | 财政部    |
|      4 | D        |   24 |     202 |     200 | 人事部    |
|      4 | D        |   24 |     202 |     201 | 技术部    |
|      4 | D        |   24 |     202 |     202 | 销售部    |
|      4 | D        |   24 |     202 |     203 | 财政部    |
|      5 | E        |   20 |     200 |     200 | 人事部    |
|      5 | E        |   20 |     200 |     201 | 技术部    |
|      5 | E        |   20 |     200 |     202 | 销售部    |
|      5 | E        |   20 |     200 |     203 | 财政部    |
|      6 | F        |   38 |     204 |     200 | 人事部    |
|      6 | F        |   38 |     204 |     201 | 技术部    |
|      6 | F        |   38 |     204 |     202 | 销售部    |
|      6 | F        |   38 |     204 |     203 | 财政部    |
+--------+----------+------+---------+---------+-----------+


2.内连接
-- 查询两张表中都有的关联数据,相当于利用条件从笛卡尔积结果中筛选出了正确的结果。

  select * from employee,department where employee.dept_id = department.dept_id;
--select * from employee inner join department on employee.dept_id = department.dept_id;

      +--------+----------+------+---------+---------+-----------+
      | emp_id | emp_name | age  | dept_id | dept_id | dept_name |
      +--------+----------+------+---------+---------+-----------+
      |      1 | A        |   19 |     200 |     200 | 人事部    |
      |      2 | B        |   26 |     201 |     201 | 技术部    |
      |      3 | C        |   30 |     201 |     201 | 技术部    |
      |      4 | D        |   24 |     202 |     202 | 销售部    |
      |      5 | E        |   20 |     200 |     200 | 人事部    |
      +--------+----------+------+---------+---------+-----------+


3.外连接
--（1）左外连接：在内连接的基础上增加左边有右边没有的结果

 select * from employee left join department on employee.dept_id = department.dept_id;

     +--------+----------+------+---------+---------+-----------+
    | emp_id | emp_name | age  | dept_id | dept_id | dept_name |
    +--------+----------+------+---------+---------+-----------+
    |      1 | A        |   19 |     200 |     200 | 人事部    |
    |      5 | E        |   20 |     200 |     200 | 人事部    |
    |      2 | B        |   26 |     201 |     201 | 技术部    |
    |      3 | C        |   30 |     201 |     201 | 技术部    |
    |      4 | D        |   24 |     202 |     202 | 销售部    |
    |      6 | F        |   38 |     204 |    NULL | NULL      |
    +--------+----------+------+---------+---------+-----------+

 --（2）右外连接：在内连接的基础上增加右边有左边没有的结果

 select * from employee RIGHT JOIN department on employee.dept_id = department.dept_id;

        +--------+----------+------+---------+---------+-----------+
        | emp_id | emp_name | age  | dept_id | dept_id | dept_name |
        +--------+----------+------+---------+---------+-----------+
        |      1 | A        |   19 |     200 |     200 | 人事部    |
        |      2 | B        |   26 |     201 |     201 | 技术部    |
        |      3 | C        |   30 |     201 |     201 | 技术部    |
        |      4 | D        |   24 |     202 |     202 | 销售部    |
        |      5 | E        |   20 |     200 |     200 | 人事部    |
        |   NULL | NULL     | NULL |    NULL |     203 | 财政部    |
        +--------+----------+------+---------+---------+-----------+

 --（3）全外连接：在内连接的基础上增加左边有右边没有的和右边有左边没有的结果

    -- mysql不支持全外连接 full JOIN
    -- mysql可以使用此种方式间接实现全外连接

   select * from employee RIGHT JOIN department on employee.dept_id = department.dept_id
   UNION
   select * from employee LEFT JOIN department on employee.dept_id = department.dept_id;



        +--------+----------+------+---------+---------+-----------+
        | emp_id | emp_name | age  | dept_id | dept_id | dept_name |
        +--------+----------+------+---------+---------+-----------+
        |      1 | A        |   19 |     200 |     200 | 人事部    |
        |      2 | B        |   26 |     201 |     201 | 技术部    |
        |      3 | C        |   30 |     201 |     201 | 技术部    |
        |      4 | D        |   24 |     202 |     202 | 销售部    |
        |      5 | E        |   20 |     200 |     200 | 人事部    |
        |   NULL | NULL     | NULL |    NULL |     203 | 财政部    |
        |      6 | F        |   38 |     204 |    NULL | NULL      |
        +--------+----------+------+---------+---------+-----------+

      -- 注意 union与union all的区别：union会去掉相同的纪录


多表查询之复合条件连接查询====================================================
-- 查询员工年龄大于等于25岁的部门

    SELECT DISTINCT department.dept_name
    FROM employee,department
    WHERE employee.dept_id = department.dept_id
    AND age>25;


--以内连接的方式查询employee和department表，并且以age字段的升序方式显示

    select employee.emp_id,employee.emp_name,employee.age,department.dept_name
    from employee,department
    where employee.dept_id = department.dept_id
    order by age asc;


多表查询之子查询==========================================================
-- 子查询是将一个查询语句嵌套在另一个查询语句中。
-- 内层查询语句的查询结果，可以为外层查询语句提供查询条件。
-- 子查询中可以包含：IN、NOT IN、ANY、ALL、EXISTS 和 NOT EXISTS等关键字
-- 还可以包含比较运算符：= 、 !=、> 、<等


-- 1. 带IN关键字的子查询

   ---查询employee表，但dept_id必须在department表中出现过

   select * from employee
            where dept_id IN
            (select dept_id from department);


+--------+----------+------+---------+
| emp_id | emp_name | age  | dept_id |
+--------+----------+------+---------+
|      1 | A        |   19 |     200 |
|      2 | B        |   26 |     201 |
|      3 | C        |   30 |     201 |
|      4 | D        |   24 |     202 |
|      5 | E        |   20 |     200 |
+--------+----------+------+---------+
rows in set (0.01 sec)


-- 2. 带比较运算符的子查询
      --      =、!=、>、>=、<、<=、<>

     -- 查询员工年龄大于等于25岁的部门
     select dept_id,dept_name from department
           where dept_id IN
          (select DISTINCT dept_id from employee where age>=25);

-- 3. 带EXISTS关键字的子查询

-- EXISTS关字键字表示存在。在使用EXISTS关键字时，内层查询语句不返回查询的记录。
-- 而是返回一个真假值。Ture或False
-- 当返回Ture时，外层查询语句将进行查询；当返回值为False时，外层查询语句不进行查询

     select * from employee
              WHERE EXISTS
              (SELECT dept_name from department where dept_id=203);

      --department表中存在dept_id=203，Ture


     select * from employee
                WHERE EXISTS
              (SELECT dept_name from department where dept_id=205);

     -- Empty set (0.00 sec)


    ps:  create table t1(select * from t2);

delimiter分隔符===============================================================================
一般来说分隔符是分号；
当你想把分隔符换成其他符号时可以这么做delimiter :   这个时候就以冒号作为分隔符，语句结束的时候就要输入冒号。

调用函数===================================================================================

create procedure autoinsert2（）
BEGIN
declare i int default 1
while（i<5000）do
insert into t2 values(i,"you")
set i=i+1
end while
END;

call autoinsert2();-----------执行函数




pymysql用python操作数据库======================================================================

import pymysql
conn=pymysql.connect(host="127.0.0.1",port=3306,user="root",passwd="1023222384",db="s5")--------连接数据库并赋值给对象conn
cursor=conn.cursor()  							----------创建游标，接下来的操作都由游标去完成
sql="CREATE TABLE test(id int ,name VARCHAR (20)"				----------将命令封装到sql变量里面
sql2="INSERT INTO test5 values(10,'alex'),(20,'xixi')"
cursor.execute(sql)								----------执行语句sql，sql为你想要执行的操作，比如创建表，插入数据等，格式为字符串
cursor.execute(sql2)
conn.commit()								----------提交数据到数据库，只有执行这一步，sql2中的插入数据操作才能执行成功
cursor.close()								----------关闭游标
conn.close()								----------关闭接口conn

通过select * from table来筛选数据、查询数据：
ret=cursor.execute("select * from table")----------返回的ret是table的行数，即纪录的条数

想要获取查询到的数据可以这么做：
cursor.fetchone()			--------获取查询结果中的一条数据
cursor.fetchall()			--------获取全部的查询结果
cursor.fetchmany(3)			--------获取查询结果中的3条数据
（注意，上述操作类似于文档操作，比如说当你用fetchone获取到了第一条数据，接下来你再使用fetchone时获取的是第二条数据）
（该操作的前提是前面必须有cursor.execute，比如说cursor.execute("select * from test")，这时候使用fetchone查询到的是test的第一行数据，再比如cursor.execute("show tables")，这时候使用fetchalll查到的是所有的表名）
调节数据显示格式：
更改获取数据结果的数据类型,默认是元组,可以改为字典等:conn.cursor(cursor=pymysql.cursors.DictCursor)

移动光标：cursor.scroll(1,mode="relative")--------将光标相对当前位置往后移动一个单位（mode还有absolute，即绝对位置）



事务命令==================================================================================
--        start transaction 开启事务
--        Rollback 回滚事务,即撤销指定的sql语句(只能回退insert delete update语句)，回滚到上一次commit的位置
--        Commit 提交事务，提交未存储的事务
--        savepoint 保留点 ，事务处理中设置的临时占位符 你可以对它发布回退(与整个事务回退不同)

---------------------------------python中开启事务的实例---------------------------------
import pymysql

#添加数据

conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='', db='yyy')

cursor = conn.cursor()


try:
    insertSQL0="INSERT INTO ACCOUNT2 (name,balance) VALUES ('oldboy',4000)"
    insertSQL1="UPDATE account2 set balance=balance-30 WHERE name='yuan'"
    insertSQL2="UPDATE account2 set balance=balance+30 WHERE name='xialv'"

    cursor = conn.cursor()

    cursor.execute(insertSQL0)
    conn.commit()------------------------第一次提交数据到数据库

    cursor.execute(insertSQL1)
    raise Exception
    cursor.execute(insertSQL2)
    cursor.close()
    conn.commit()

except Exception as e:

    conn.rollback()------------------------出错的话回滚到上一次commit，记住这不是跳转，只是清空了出错位置和上一次commit之间的操作
    conn.commit()------------------------提交操作到数据库


cursor.close()
conn.close()


------------------------------------命令行中的事务操作savepoint--------------------------------------
create table test2(id int PRIMARY KEY auto_increment,name VARCHAR(20)) engine=innodb;----------engine规定搜索引擎为innodb，其实默认的也是innodb。
INSERT INTO test2(name) VALUE ("alvin"),
                              ("yuan"),
                              ("xialv");

start transaction;
insert into test2 (name)values('silv');
select * from test2;
commit;
------------上面操作通过commit后完成----------

start transaction;
insert into test2 (name)values('wu');
savepoint insert_wu;-------------------------创建节点insert_wu

delete from test2 where id=4;
savepoint delete1;---------------------------创建节点delete1

delete from test2 where id=1;
savepoint delete2;---------------------------创建节点delete2

rollback to delete1;--------------------------回退到delete1，也就是说delete1之前的操作会被保留，而delete1后面的操作将会失效。

（在命令行中，默认不开启事务，需要手动输入start transaction，这之前每一步操作都是直接对数据库进行修改，一旦开启事务，就需要使用commit来进行提交数据，才能对数据库惊醒改变，而python中默认开启事务，所有操作都必须使用commit才能起到效果）potplay快捷键.txt----------------------------------------------------------------------------------------------------

快捷键            指令

--------------------------------------------------------

"              播放->跳略播放->跳略播放 开|关

'              播放->跳略播放->跳略播放设置...

,              字幕->字幕同步(帧率)->滞后0.5 秒

Alt+,        字幕->字幕同步(帧率)->滞后50 秒

.              字幕->字幕同步(帧率)->超前0.5 秒

Alt+.        字幕->字幕同步(帧率)->超前50 秒

/              字幕->字幕同步(帧率)->复位

<             字幕->字幕同步(帧率)->滞后0.5 秒

>             字幕->字幕同步(帧率)->超前0.5 秒

[              播放->AB 区段循环->设定起点

Alt+[        播放->AB 区段循环->将起点步进0.1 秒

\              播放->AB 区段循环->区段循环 开|关

Alt+\        播放->AB 区段循环->当前章节/标记/书签 区段循环

]              播放->AB 区段循环->设定止点

Alt+]        播放->AB 区段循环->将止点步进0.1 秒

`              屏幕->迷你尺寸

{              播放->AB 区段循环->解除起点

}              播放->AB 区段循环->解除止点

Backspace           播放->定位->重新开始

Shift+Backspace  播放->定位->结束前30秒

Ctrl+Backspace    播放->定位->中段

Alt+Backspace      DVD->标题菜单

Tab                        配置/语言/其他->OSD信息

Shift+Tab               配置/语言/其他->简要信息

Enter                      屏幕->全屏

Ctrl+Enter              屏幕->全屏+(拉伸)

Ctrl+Shift+Enter     屏幕->全屏(其他显示器)

Alt+Enter               屏幕->全屏

Ctrl+Alt+Enter       屏幕->全屏+(保持比例)

Space                   播放->播放|暂停

PgUp                    电视->下一频道

Shift+PgUp          上一 书签/章节

Ctrl+PgUp      电视->前一收看频道

Alt+PgUp        字幕->字幕风格->字体+

PgDn          电视->上一频道

Shift+PgDn          下一 书签/章节

Ctrl+PgDn      电视->后一收看频道

Alt+PgDn        字幕->字幕风格->字体-

End            播放->定位->下一对白

Home          播放->定位->上一对白

Ctrl+Home      播放->定位->当前字幕起点

Alt+Home        字幕->字幕风格->复位

←              播放->定位->步退5 秒

Shift+←        播放->定位->步退1 分

Ctrl+←            播放->定位->步退30 秒

Ctrl+Shift+←    播放->定位->上一关键帧

Alt+←          字幕->字幕风格->左移

Ctrl+Alt+←          播放->定位->步退5 分

↑              声音->音量+

Shift+↑        声音->播放音量控制->主音量+

Alt+↑          字幕->字幕风格->上移

Ctrl+Alt+↑          声音->系统音量->波形音量+

Ctrl+Alt+Shift+↑  声音->系统音量->主音量+

→              播放->定位->步进5 秒

Shift+→        播放->定位->步进1 分

Ctrl+→            播放->定位->步进30 秒

Ctrl+Shift+→    播放->定位->下一关键帧

Alt+→          字幕->字幕风格->右移

Ctrl+Alt+→          播放->定位->步进5 分

↓              声音->音量-

Shift+↓        声音->播放音量控制->主音量-

Alt+↓          字幕->字幕风格->下移

Ctrl+Alt+↓          声音->系统音量->波形音量-

Ctrl+Alt+Shift+↓  声音->系统音量->主音量-

Insert            电视->最后收看频道

Ctrl+Insert      收藏->添加当前文件夹

Alt+Insert          收藏->添加当前文件

Delete            电视->跳转至指定频道...

Shift+Delete    播放->播放列表->删除->删除文件

Ctrl+Shift+Delete 播放->播放列表->删除->删除文件(+字幕)

0              屏幕->自定义尺寸设置...

1              屏幕->半倍屏

Alt+1          屏幕->显示器30% 尺寸

2              屏幕->1 倍屏

Alt+2          屏幕->显示器45% 尺寸

3              屏幕->1.5 倍屏

Alt+3          屏幕->显示器60% 尺寸

4              屏幕->2.0 倍屏

Alt+4          屏幕->显示器75% 尺寸

5              屏幕->最大化

6              屏幕->最大化|还原

7              屏幕->最大化+(过任务栏)|还原

8              屏幕->无边框尺寸

9              屏幕->自定义尺寸

A              声音->选择声音

Shift+A        声音->声音处理->语音增强

Alt+A          声音->选择声音->按序切换声音

Ctrl+Alt+A          配置/语言/其他->收尾处理->依次切换收尾方式

B              播放->AB 区段循环

Ctrl+B            视频->图像处理->软模糊

Alt+B          字幕->字幕风格->粗体

Ctrl+Alt+B          视频->下边距->按序切换边距

C              播放->播放速度->加速+

Shift+C        声音->声音处理->晶化

Ctrl+C            视频->图像截取->复制当前源画面

Alt+C          视频->视频录制->录制视频...

Ctrl+Alt+C          视频->图像截取->复制当前实画面

D              播放->定位->上一帧

Shift+D        声音->声音处理->降噪

Ctrl+D            打开->DVD 设备

Alt+D          打开->设备设置...

Ctrl+Alt+D          打开->蓝光设备

E              视频->亮度+1%

Shift+E        声音->均衡器

Ctrl+E            视频->图像截取->截存当前源画面

Alt+E          字幕->字幕浏览器...

Ctrl+Alt+E          视频->图像截取->截存当前实画面

F              播放->定位->下一帧

Ctrl+F            滤镜->滤镜/解码器管理...

Alt+F          字幕->字幕风格->字体设置...

G              播放->定位->手动定位...

Shift+G        声音->音轨->声音录制...

Ctrl+G            视频->图像截取->连续截图...

Alt+G          电视->频道控制->频道管理...

H              播放->章节/书签

Shift+H        声音->音调->低音

Ctrl+H            视频->图像处理->去块(提高画质)

Alt+H          字幕->显示字幕

I              视频->色彩度-1%

Ctrl+I            视频->反交错->切换反交错方式

J              视频->3D 视频输出

Shift+J        声音->音调->高音

Ctrl+J            打开->摄像头/其他设备

K              视频->图像截取

Shift+K        声音->音调->默认音调

Ctrl+K            打开->数字TV(BDA 设备)

Alt+K          视频->图像旋转->按序选择旋转方式

L              字幕->选择字幕

Shift+L        配置/语言/其他->语言

Ctrl+L            视频->图像处理->电平控制

Alt+L          字幕->选择字幕->依次选择字幕

M              声音->静音

Ctrl+M            视频->图像处理->瞬态降噪

Ctrl+Alt+M          声音->系统音量->静音

Ctrl+Alt+Shift+M  声音->系统音量->静音

N              电视->频道控制

Shift+N        声音->声音处理->规格化

Ctrl+N            视频->图像处理->3D 降噪

Alt+N          视频->图像截取->创建缩略图...

O              视频->色彩度+1%

Ctrl+O            打开->打开文件...

Alt+O          打开->打开字幕...

P              播放->章节/书签->添加书签

Shift+P        视频->像素着色->调整尺寸前的着色切换

Ctrl+P            视频->图像处理->上下翻转

Alt+P          字幕->手动输入字幕...

Ctrl+Alt+P          视频->像素着色->调整尺寸后的着色切换

Q              视频->图像属性复位

Ctrl+Q            视频->裁剪/拉伸->图像缩放设置...

R              视频->对比度-1%

Shift+R        声音->声音处理->混响

Ctrl+R            视频->图像处理->锐化

S              视频->像素着色

Ctrl+S            打开->采集器

Ctrl+Shift+S    字幕->保存字幕->按影片名称保存

Alt+S          字幕->保存字幕->回写SMI字幕

Ctrl+Alt+S          字幕->保存字幕->另存字幕为...

T              视频->对比度+1%

Shift+T        声音->声音处理->左右声道互换

Ctrl+T            配置/语言/其他->置顶方式->切换最前端

U              视频->饱和度+1%

Ctrl+U            打开->打开链接...

V              视频->选择图像

Shift+V        声音->声音处理->语音消除

Ctrl+V            打开->打开剪贴板

Alt+V          视频->选择图像->图像顺序选择

W              视频->亮度-1%

Ctrl+W            打开->模拟TV

X              播放->播放速度->减速-

Shift+X        声音->开启声音处理滤镜

Ctrl+X            视频->图像处理滤镜->依次切换图像处理滤镜

Y              视频->饱和度-1%

Ctrl+Y            打开->重开当前/最后文件

Ctrl+Alt+Y          打开->重载字幕

Z              播放->播放速度->正常/之前的速度

Shift+Z        播放->定位->时间场景浏览...

Ctrl+Z            视频->图像处理->左右翻转

Alt+Z          播放->定位->章节/书签场景浏览...

Numpad 0        帧位->预置->选择预置顺序

Numpad 1        帧位->全帧-

Ctrl+Alt+Numpad 1 屏幕->窗口定位->置于?

Numpad 2        帧位->帧高-

Ctrl+Numpad 2    帧位->偏移↓

Alt+Numpad 2    字幕->字幕风格->上下边距-

Ctrl+Alt+Numpad 2 屏幕->窗口定位->位移↓

Ctrl+Alt+Numpad 3 屏幕->窗口定位->置于?

Numpad 4        帧位->帧宽-

Ctrl+Numpad 4    帧位->偏移←

Alt+Numpad 4    字幕->字幕风格->左右边距-

Ctrl+Alt+Numpad 4 屏幕->窗口定位->位移←

Numpad 5        帧位->帧位 之前/复位

Ctrl+Numpad 5    帧位->帧位居中

Ctrl+Alt+Numpad 5 屏幕->窗口定位->外框居中

Numpad 6        帧位->帧宽+

Ctrl+Numpad 6    帧位->偏移→

Alt+Numpad 6    字幕->字幕风格->左右边距+

Ctrl+Alt+Numpad 6 屏幕->窗口定位->位移→

Ctrl+Alt+Numpad 7 屏幕->窗口定位->置于?

Numpad 8        帧位->帧高+

Ctrl+Numpad 8    帧位->偏移↑

Alt+Numpad 8    字幕->字幕风格->上下边距+

Ctrl+Alt+Numpad 8 屏幕->窗口定位->位移↑

Numpad 9        帧位->全帧+

Ctrl+Alt+Numpad 9 屏幕->窗口定位->置于?

Add            帧位->全帧+

Ctrl+Alt+Add    屏幕->窗口+

Subtract        帧位->全帧-

Ctrl+Alt+Subtract 屏幕->窗口-

F1                关于...

Ctrl+F1        属性...

Ctrl+Alt+F1      直播->采集器I

F2                打开->打开文件夹...

Ctrl+Alt+F2      直播->采集器II

F3                打开文件...

Ctrl+Alt+F3      直播->采集器I开始

F4                关闭

Ctrl+Alt+F4      直播->采集器II开始

F5                选项...

Ctrl+F5        比例->依次切换比例模式

Ctrl+Alt+F5      直播->采集设置...

F6                列表...

Ctrl+F6        比例->依次切换比例

F7                控制...

F12            打开->简索->简索文件...

Ctrl+F12        打开->简索->简索菜单...

Alt+F12        打开->打开远程连接...

Scroll            配置/语言/其他->播放信息

Shift+,        声音->声音匹配(同步)->滞后0.05 秒

Ctrl+,            字幕->字幕同步(帧率)->滞后5 秒

Ctrl+Alt+,          字幕->字幕同步(帧率)->上一字幕同步

Shift+.        声音->声音匹配(同步)->超前0.05 秒

Ctrl+.            字幕->字幕同步(帧率)->超前5 秒

Ctrl+Alt+.          字幕->字幕同步(帧率)->下一字幕同步

Shift+/        声音->声音匹配(同步)->复位

Ctrl+[            播放->AB 区段循环->将起点步退0.1 秒

Ctrl+Alt+[          播放->AB 区段循环->将循环区步退0.1 秒

Shift+\        播放->AB 区段循环->编辑AB区段循环列表...

Ctrl+\            播放->AB 区段循环->循环当前字幕

Ctrl+]            播放->AB 区段循环->将止点步退0.1 秒

Ctrl+Alt+]          播放->AB 区段循环->将循环区步进0.1 秒pycharm常用设置.txt----------------------------------------------------------------------------------------------------
1、编辑（Editing）
Ctrl + Space 基本的代码完成（类、方法、属性）
Ctrl + Alt + Space 快速导入任意类
Ctrl + Shift + Enter 语句完成
Ctrl + P 参数信息（在方法中调用参数）
Ctrl + Q 快速查看文档
Shift + F1 外部文档
Ctrl + 鼠标 简介
Ctrl + F1 显示错误描述或警告信息
Alt + Insert 自动生成代码
Ctrl + O 重新方法
Ctrl + Alt + T 选中
Ctrl + / 行注释
Ctrl + Shift + / 块注释
Ctrl + W 选中增加的代码块
Ctrl + Shift + W 回到之前状态
Ctrl + Shift + ]/[ 选定代码块结束、开始
Alt + Enter 快速修正
Ctrl + Alt + L 代码格式化
Ctrl + Alt + O 优化导入
Ctrl + Alt + I 自动缩进
Tab / Shift + Tab 缩进、不缩进当前行
Ctrl+X/Shift+Delete 剪切当前行或选定的代码块到剪贴板
Ctrl+C/Ctrl+Insert 复制当前行或选定的代码块到剪贴板
Ctrl+V/Shift+Insert 从剪贴板粘贴
Ctrl + Shift + V 从最近的缓冲区粘贴
Ctrl + D 复制选定的区域或行
Ctrl + Y 删除选定的行
Ctrl + Shift + J 添加智能线
Ctrl + Enter 智能线切割
Shift + Enter 另起一行
Ctrl + Shift + U 在选定的区域或代码块间切换
Ctrl + Delete 删除到字符结束
Ctrl + Backspace 删除到字符开始
Ctrl + Numpad+/- 展开折叠代码块
Ctrl + Numpad+ 全部展开
Ctrl + Numpad- 全部折叠
Ctrl + F4 关闭运行的选项卡

2、查找/替换(Search/Replace)
F3 下一个
Shift + F3 前一个
Ctrl + R 替换
Ctrl + Shift + F 全局查找
Ctrl + Shift + R 全局替换

3、运行(Running)
Alt + Shift + F10 运行模式配置
Alt + Shift + F9 调试模式配置
Shift + F10 运行
Shift + F9 调试
Ctrl + Shift + F10 运行编辑器配置
Ctrl + Alt + R 运行manage.py任务

4、调试(Debugging)
F8 跳过
F7 进入
Shift + F8 退出
Alt + F9 运行游标
Alt + F8 验证表达式
Ctrl + Alt + F8 快速验证表达式
F9 恢复程序
Ctrl + F8 断点开关
Ctrl + Shift + F8 查看断点

5、导航(Navigation)
Ctrl + N 跳转到类
Ctrl + Shift + N 跳转到符号
Alt + Right/Left 跳转到下一个、前一个编辑的选项卡
F12 回到先前的工具窗口
Esc 从工具窗口回到编辑窗口
Shift + Esc 隐藏运行的、最近运行的窗口
Ctrl + Shift + F4 关闭主动运行的选项卡
Ctrl + G 查看当前行号、字符号
Ctrl + E 当前文件弹出
Ctrl+Alt+Left/Right 后退、前进
Ctrl+Shift+Backspace 导航到最近编辑区域
Alt + F1 查找当前文件或标识
Ctrl+B / Ctrl+Click 跳转到声明
Ctrl + Alt + B 跳转到实现
Ctrl + Shift + I查看快速定义
Ctrl + Shift + B跳转到类型声明
Ctrl + U跳转到父方法、父类
Alt + Up/Down跳转到上一个、下一个方法
Ctrl + ]/[跳转到代码块结束、开始
Ctrl + F12弹出文件结构
Ctrl + H类型层次结构
Ctrl + Shift + H方法层次结构
Ctrl + Alt + H调用层次结构
F2 / Shift + F2下一条、前一条高亮的错误
F4 / Ctrl + Enter编辑资源、查看资源
Alt + Home显示导航条F11书签开关
Ctrl + Shift + F11书签助记开关
Ctrl + #[0-9]跳转到标识的书签
Shift + F11显示书签

6、搜索相关(Usage Search)
Alt + F7/Ctrl + F7文件中查询用法
Ctrl + Shift + F7文件中用法高亮显示
Ctrl + Alt + F7显示用法

7、重构(Refactoring)
F5复制F6剪切
Alt + Delete安全删除
Shift + F6重命名
Ctrl + F6更改签名
Ctrl + Alt + N内联
Ctrl + Alt + M提取方法
Ctrl + Alt + V提取属性
Ctrl + Alt + F提取字段
Ctrl + Alt + C提取常量
Ctrl + Alt + P提取参数

8、控制VCS/Local History
Ctrl + K提交项目
Ctrl + T更新项目
Alt + Shift + C查看最近的变化
Alt + BackQuote(’)VCS快速弹出

9、模版(Live Templates)
Ctrl + Alt + J当前行使用模版
Ctrl +Ｊ插入模版

10、基本(General)
Alt + #[0-9]打开相应的工具窗口
Ctrl + Alt + Y同步
Ctrl + Shift + F12最大化编辑开关
Alt + Shift + F添加到最喜欢
Alt + Shift + I根据配置检查当前文件
Ctrl + BackQuote(’)快速切换当前计划
Ctrl + Alt + S　打开设置页
Ctrl + Shift + A查找编辑器里所有的动作
Ctrl + Tab在窗口间进行切换

一些常用设置：
1. pycharm默认是自动保存的，习惯自己按ctrl + s 的可以进行如下设置：
1. file -> Setting -> General -> Synchronization -> Save files on frame deactivation 和 Save files automatically if application is idle for .. sec 的勾去掉
2. file ->Setting -> Editor -> Editor Tabs -> Mark modified tabs with asterisk 打上勾
2. Alt + Enter: 自动添加包

3. 对于常用的快捷键，可以设置为visual studio(eclipse...)一样的：
file -> Setting -> Keymap -> Keymaps -> vuisual studio -> Apply

4. Pycharm中默认是不能用Ctrl+滚轮改变字体大小的，可以在file -> Setting ->Editor-〉Mouse中设置

5. 要设置Pycharm的字体，要先在file -> Setting ->Editor-〉Editor中选择一种风格并保存，然后才可以改变

6. 在setting中搜索theme可以改变主题，所有配色统一改变PyQt5.txt----------------------------------------------------------------------------------------------------
pyqt5:

设计进度条：
from PyQt5.QtWidgets import QApplication,QWidget,QProgressBar,QPushButton
from PyQt5.QtGui import QIcon #往窗口上设置图形
from PyQt5.QtCore import QBasicTimer #计时器
import sys
#创建一个窗口类
class Example(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()
        #发射信号
        self.btn.clicked.connect(self.doAction)
    def initUI(self):
        #构建一个进度条
        self.pbar=QProgressBar(self)
        #从屏幕左上角开始，绘制一个280*170的窗口，（300,300）指的是窗口显示的位置距离电脑屏幕左上角300，300的位置
        self.setGeometry(300, 300, 280, 170)
        #从设置的窗口左上角开始，绘制一个200*30的进度条，（200,30）指的是窗口显示的位置距离设置窗口左上角200,30的位置
        self.pbar.setGeometry(30, 50, 200, 30)
        #创建运行按钮
        self.btn=QPushButton("开始",self)
        #移动按钮
        self.btn.move(75,90)
        #构建计时器
        self.timer=QBasicTimer()
        #设置进度条的初始值
        self.step=0
        #设置窗口标题
        self.setWindowTitle("guangjin")
        #创建窗口图标
        self.setWindowIcon(QIcon("beijing2.png"))
        #显示绘制页面
        self.show()
    def doAction(self):
        #判断是否处于激活状态
        if self.timer.isActive():
            self.timer.stop()
            self.btn.setText("开始")
        else:
            self.timer.start(6,self)
            self.btn.setText("停止")
    def timerEvent(self,*args,**kwargs):
        if self.step>=100:
            self.timer.stop()
            self.btn.setText("完成")
        self.step=self.step+1
        self.pbar.setValue(self.step)

if __name__=="__main__":
    #构建一个QT对象
    app=QApplication(sys.argv)
    ex=Example()
    #执行函数
    sys.exit(app.exec_())









python课程网址.txt----------------------------------------------------------------------------------------------------
数据库基础https://www.cnblogs.com/yuanchenqi/articles/6357507.html
数据库进阶https://www.cnblogs.com/yuanchenqi/articles/6437362.html
http协议https://www.cnblogs.com/yuanchenqi/articles/6000358.html
djangohttps://www.cnblogs.com/yuanchenqi/articles/6083427.html同步对象event,线程数量.txt----------------------------------------------------------------------------------------------------
同步对象：event
import threading
event=threading.Event() 创建对象

event.isSet()：返回event的状态值；

event.wait()：如果 event.isSet()==False将阻塞线程；

event.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；

event.clear()：恢复event的状态值为False。
例如：
import threading,time
class Boss(threading.Thread):
    def run(self):
        print("BOSS：今晚大家都要加班到22:00。")
        print(event.isSet())
        event.set()
        time.sleep(5)
        print("BOSS：<22:00>可以下班了。")
        print(event.isSet())
        event.set()
class Worker(threading.Thread):
    def run(self):
        event.wait()
        print("Worker：哎……命苦啊！")
        time.sleep(1)
        event.clear()
        event.wait()
        print("Worker：OhYeah!")
if __name__=="__main__":
    event=threading.Event()
    threads=[]
    for i in range(5):
        threads.append(Worker())
    threads.append(Boss())
    for t in threads:
        t.start()
    for t in threads:
        t.join()



信号量：Semaphore（控制线程输数量）
      信号量用来控制线程并发数的，BoundedSemaphore或Semaphore管理一个内置的计数 器，每当调用acquire()时-1，调用release()时+1。

      计数器不能小于0，当计数器为 0时，acquire()将阻塞线程至同步锁定状态，直到其他线程调用release()。(类似于停车位的概念)

      BoundedSemaphore与Semaphore的唯一区别在于前者将在调用release()时检查计数 器的值是否超过了计数器的初始值，如果超过了将抛出一个异常。

import threading,time
class MyThread(threading.Thread):
    def run(self):
        if semaphore.acquire():
            print(self.name)
            time.sleep(5)
            semaphore.release()
if __name__=="__main__":
    semaphore=threading.Semaphore(5)
    thrs=[]
    for i in range(100):
        thrs.append(MyThread())
    for t in thrs:
        t.start()同步，异步，锁.txt----------------------------------------------------------------------------------------------------
同步锁，递归锁


并发：指系统具有处理多个任务的能力（系统不断切换处理任务，但一个时刻只处理一个任务）
并行：指系统具有同时处理多个任务的能力（一个时刻可以处理多个任务）

同步与异步
同步：当一个进程需要进行IO操作（等待外部数据）的时候，你有两种选择  ------等：同步
                                                                                                            ------不等：异步，去干其他事情，直到收到数据再回来处理

GIL：全局解释锁，同一时刻，只有一个线程被执行。

同步锁：
import threading
lock=threading.Lock() 创建锁（只能同时存在一把锁）

lock.acquire() 获取锁
---
---代码块 （在执行中间代码块的时候cpu不准切换，直到代码块被执行完成为止）
---
lock.release() 释放锁


递归锁：
import threading
r_lock=threading.RLock() 创建锁（可同时存在多把锁，当内部计数器大于1时，其他线程无法获取这把锁）

爬虫（http协议）.txt----------------------------------------------------------------------------------------------------
http协议的请求介绍：
（免费代理网址：https://www.xicidaili.com/）
get：向特定的资源发出请求
post：向指定资源提交数据进行数据请求，数据被包含在请求体里
put：向指定资源位置上传其最新内容
delete：请求服务器删除request-url所标识的资源
head：只请求页面额首部
options：允许客户端查看服务器的性能


r.content：获取响应体的二进制信息（图片视频等都是以二进制形式获取的）
r.text：获取响应体的文本信息
r.encoding：r的编码格式（可以通过r.encoding="gzip"来设置r的编码格式）
r.url：查看r访问的网址
r.status_code：状态码（2开头表示成功，3开头重定向，4开头请求错误，5开头服务器错误）



import requests
dict={"q":"java"，"p":"python"}
dict2={cookies}
r=requests.get(timeout=3，cookies=dict2，params=dict,url="https://www.douban.com",headers={'User-Agent':'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36'})
（params为网址后面的参数，以字典的形式传进去，这里查看url，可以发现构造出来的网址为https://www.douban.com?q=java&p=python）
（cookies以字典的形式上传，timeout=3意思是等待3秒，如果3秒过后没有得到相应将中断请求）
r.encoding="gzip"
print(r.url)

session会话：保持状态
s=requests.session()
然后就可以使用s.get()、s.post()等等了

proxies代理：
proxies={"http"："代理地址，可以写多个"}（代理类型有“https”，“http”）
r=requests.get("http://www.douban.com"，proxies=proxies)

-------------------------------------------------------------------------
xpath：
import requests
from lxml import etree

测试文本：aa
<div>
    <li class="item-inactive"><a href="www.baidu.com"></a></li>
    <li><h1>555</h1></li>
    <li></li>
    <li></li>
    <li></li>
</div>

查找出所有的li标签：
selector=etree.HTML(aa)
all_li=selector.xpath("//div/li")--------//指的是根节点

查找出第一个li元素，注意这里的序号是从1开始的：
li_1=selector.xpath("//div/li[1]")

提取出a标签里面的文本：
a1_wenben=selector.xpath("//div/li[1]/a/text()")-----text()提取文本，提取出来的结果是一个列表

通过属性来查找：
selector.xpath('//div/li[@class="item-inactive"]')---由于在这里这个class是独一无二的，所以可以这样简写，"//li[@class="item-inactive"]"
（*，还可以这样写，“//*[@class="item-inactive"] ”，*表示根节点下面所有的标签）
（当然也可以通过href属性来定位，"//*[@href='www.baidu.com']"）

提取href的值，提取属性的值：
"//li/a/@href"
（同理，提取class的属性，"//*/@class"）

xpath的高级用法：
提取所有的含有以“item-”开头的class属性的li标签：
"//li [ starts-with（@class，“item-”）]"

当然也可以对已经提取出来的标签进行二次提取：
比如我第一次提取出来一个标签：
li_first=selector.xpath("//li[1]")[0]
然后再提取出li_first里面的li标签：
li_second=li_first.xpath("li")[0]

提取所有文本：
.xpath("string（//li）")-----意思是，提取根节点下所有的li标签里面的所有文本


反反爬虫方法：
1.设置headers
2.保存cookies
3.设置timesleep
4.设置proxies
5.爬取移动页面
6.selenium





//*[@id="wp_news_w88"]/ul/li/div[2]/span/a/img

















环境变量.txt----------------------------------------------------------------------------------------------------
D:\广厦CAD安装路径\gsplot;C:\Program Files\MySQL\MySQL Shell 8.0\bin\;C:\Program Files (x86)\Microsoft Visual Studio\Shared\Anaconda3_64\Scripts;C:\Program Files\MySQL\MySQL Server 8.0\bin\;C:\Users\82021\AppData\Local\Programs\Python\Python37\;非阻塞，selector模块.txt----------------------------------------------------------------------------------------------------
非阻塞，selectors模块

import selectors
from socket import *

def accept(args, kwargs):
    conn, addr = sock.accept()  # Should be ready   ---------建立链接
    print('accepted', conn, 'from', addr)
    conn.setblocking(False)                                      ---------将链接设为非阻塞状态
    sel.register(conn, selectors.EVENT_READ, read)   ---------注册，将conn与read函数绑定（在select中，这一步相当于把建立好的链接conn放进监测列表中）

def read(conn,mask):
    try:
        data = conn.recv(1000)  # Should be ready
        print('echoing', repr(data), 'to', conn)
        conn.send(data)  # Hope it won't block
    except Exception as e:
        print('closing', conn)
        sel.unregister(conn)                                        --------一旦断开链接，注销注册信息（相当于在select中把conn从监听列表中删除）
        conn.close()

sk = socket(AF_INET,SOCK_STREAM)
sk.bind(("127.0.0.1",8080))
sk.listen(5)
sk.setblocking(False)   ---------------------------------将socket设置为非阻塞状态，socket必须在非阻塞情况下才能实现IO多路复用
# 这里如果直接 server.accept() ，如果没有连接会报错，所以有数据才调他们
# BlockIOError：[WinError 10035] 无法立即完成一个非阻塞性套接字操作。

sel=selectors.DefaultSelector()   -----------------------对象实例化
sel.register(sk, selectors.EVENT_READ, accept)   -----------注册，将sk与accept绑定（在select中，这一步相当于把sk放进监听列表中）

while True:
    events=sel.select()   ---------------------------------启动监听
    for key,mask in events:
        callback=key.data   -------------------------------callback就是此次触发对象所绑定的函数。
        callback(key.fileobj, mask)   -----------------------只要关注key.fileobj就可以了，它指的是活动的对象，即此次监听的对象。













