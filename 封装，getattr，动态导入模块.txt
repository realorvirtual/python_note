封装：
第一层面：类的本身就是一种封装。第二层面：在类的内部定义私有的，外部无法访问的。第三层面：明确区分内外，内部实现的逻辑，外部无法知晓。
明确地区分内部和外部，内部指的是class内部，外部指的是外部调用。
在class内部定义的函数的函数名（数据属性也可以）前面加上__，例如__star，那么在外部调用的时候不能使用 实例.__star去调用，而是要用 实例._类__star去调用，相当于给函数换了名字。

反射：主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。
hasattr(object，name)判断object中有没有一个name字符串对应的方法或属性（也就是object能不能调用得到name对应的方法或者属性，注意name为字符串）。返回值True or False。
getattr(object，name，“找不到的时候返回这个字符串”)返回name对应的方法或者属性，如果是方法的话，可以在返回值后面加（）来执行这个函数。第三个参数的意思是如果找不到的话，会返回后面的字符出。
setattr(object，"字符串或者函数"，值)给object对象设置属性，相当于object.key=value（就是给实例增加属性）。
delattr(object，"字符串")删除属性。
（以上方法同样适用于类）

动态导入模块：
abc=__import__("模块名")，但是注意，如果模块外面有很多层文件，那么，想调用最里面那层文件，要这样做，m1.m2.m3.m4.m5。
from abc import *导入模块abc所有的内容。

调用len(str)实际上是在调用str.__len__()

面向对象进阶：
在class内定义一个__getattr__(self,item)，在该class实例化之后，实例调用class里面的属性或者函数，如果函数存在，则正常运行，如果函数或者属性不存在，那么该__getattr__函数就会执行。
在class内定义一个__delattr__(self,item)，在进行del或者delattr操作时会执行该函数。
在class内定义一个__setattr__(self,key,value)，实例在进行设置或者__setattr__操作时便会执行该函数，key是设置的变量，value是赋予的值。
注意，在给实例增加属性的时候，例如f1.abc="abc"，在实例的属性字典里面是找不到abc的，所以，要这么操作：f1.__dict__["abc"]="abc"，直接操作属性字典就可以了。（给实例加属性后，实例的属性字典找不到增加的内容怎么办？）

授权：授权是包装的一个特性，包装一个类型通常是对已存在的类型的一些定制，这种方法可以新建、修改或删除原有产品的功能。其他原则保持原样，授权的过程，即是所有更新的功能都是由新类的某部分来处理，但已存在的功能就授权给对象的默认属性。实现授权的关键点就是覆盖__getattr__方法。

__getitem__:执行obj[属性]（即调用函数或者属性时）触发
__setitem__:执行obj[属性]=属性值时触发
__delitem__:执行del obj[属性]时触发

__get__,__set__,__delete__触发条件：
class 描述符：
    def __get__():
        pass
    def __set__():
        pass
    def __delete__():
        pass
class 类：
    name=描述符（）
obj=类（）
obj.name  ==== 触发get
obj.name="abc"  ====触发set
del obj.name  ====触发delete

__del__：析构方法（垃圾回收时触发）

__getattribute__:只要调用属性或函数就会触发，不管存不存在。（当该函数抛出错误时，__getattr__才会触发）

