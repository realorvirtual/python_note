正则表达式re:    正则就是模糊匹配
元字符：. ^ $ * + ? {} [] | () \

. 通配符，任何字符都能匹配得上（除了换行符即\n）
例如re.findall（“a..x”，“abbxaaabbbcccabsx”）==["abbx","absx"]一个点代表字符（任意字符）。

^尖角号，只匹配字符串开头。（尖角号只能放在规则开头，例如“^a..x”）。

$dollar符，只匹配字符串结尾。（dollar符只能放在规则结尾，例如“a..x$”）。

重复符号：*，像规则a*，匹配任意数量的a。范围（0，正无穷）。
	+，类似于*。范围（1，正无穷），+与*的区别是，a+规则匹配时字符串必须要有一个a，而a*匹配时字符串里不一定要有a。
	（贪婪匹配，尽可能多地匹配）
?，如a..x?，可以匹配a..，a..x，也就是x可要可不要，即?前面的x的数量为（0，1）。
在*或者+后面再加个？可以把贪婪匹配变成惰性匹配，即尽可能少地匹配。

{}，z {x，y}匹配x――y个z，不填y表示x――正无穷。如果只写y，像z{8}，那么只能匹配8个z。

[]，x[yz]可以匹配xy，xz，不能匹配单独的x，或者单独的y，z，也不能匹配xyz。[a-z]表示字符"a"--"z"。当然也可以这样来表示0--9：[0-9]。
注意：在[]里面加入^表示“非”，例如q[^a-z]，那么只能匹配  q+非(a-z)的字符，例如q1，q2，q3，而qa，qb，qc是不能够匹配的。
编程实例：找到最里面的括号所包含的内容re.findall("\([^()]*\)","((scscs(2-1)))")==["(2-1)"]。

()，优先匹配，例如：re.findall("www.(abc),com","www.abc.com")==["abc"]，在括号里面这样写可以取消优先级(?:abc)==["www.abc.com"]
（abc|123）优先匹配abc或者123，[abc|123]与[abc123]的意义一样。
问题（已解决）："(abc)+","abcabc"==["abc"]，为什么不是["abcabc"]呢，原因就在于()的优先级，它会在匹配成功后输出()里面的内容，而不是把匹配成功的内容全部输出，这时候就可以通过取消优先级来输出全部内容"(?:abc)+","abcabc"==["abcabc"]。

\d匹配任何十进制数字，相当于[0,9]。
\D匹配任何非数字字符，相当于[^0,9]。
\s匹配任何空白字符，相当于[\t\n\r\f\v]。
\S匹配任何非空白字符。
\w匹配任何字母数字字符，包括中文。
\W匹配任何非字母数字字符。
\b匹配一个特殊字符边界，比如空格，&，#。比如我想匹配出字符串“hello i am”里面的i，可以使用规则r“\bi\b”，加上r的原因是:\b在python解释器有其独立的意义，当解释器交给re模块的时候，re收到的不再是\b，所以加上r是为了让python解释器不做任何转义，即\b就是re所需要的\b。
(也可以用\\\\来表示一个普通的\，在python解释器中四个特殊的\转为两个普通的\\，然后传到re中，re将两个特殊的\\（当普通的\\来到re时就变成特殊的了）转为一个普通的\)
|或匹配，例如ka | b，匹配ka或者b。

分组：“（?P<name>规则）”，例如一个字符串“alex20”，我想提取alex和20，并且给这两个信息分组，就可以这么做“(?P<name>[a-z]+)(?P<age>\d+)”。获取分组内容的方法：函数.group("name","age")。

re.findall(匹配规则，字符串)返回满足匹配条件的结果，以列表形式呈现。
re.search(匹配规则，字符串)只要找到一个满足条件的就返回结果（返回一个对象），可以使用.group()方法得到匹配的字符串。如果前面有分组的话，在group的括号里面填入“name”，就可以得到name对应的内容。
re.match(匹配规则，字符串)从字符串开头开始匹配，满足要求返回一个对象，可以利用.group()来得到匹配成功的字符串。（这个函数的特点就是从字符串开头开始匹配，遇到第一个满足条件的就直接返回一个对象，所以用search也同样可以完成上述功能，比如^加匹配规则就是从头开始匹配，search遇到第一个满足条件的就直接返回一个对象，两者都可以用.group()来获取满足条件的字符串）
re.split( [ 匹配规则 ] ，字符串)与python自带的split差不多，比如我想通过空格和|来分割字符串“hello abc|bcd”，就可以这么写“[ |]”,"hello abc|bcd"。
re.sub(匹配规则，替换字符串，原字符串)字符串替换，比如我想把字符串“123abc123”里面的123替换成A，可以这样写（“\d+”,"A","123abc123")==AabcA。（注意：还可以加入第四个参数，第四个参数为数字，意思是替换的次数，不写的话表示满足匹配规则的字符将全部被替换）
(上面的sub返回的是一个字符串，如果使用re.subn，返回的是一个元组tuple)

re.compile("规则")自定义函数功能，多次调用时，不必每次都输入多个参数，例如：
com=re.compile("\d+")自定义规则
com.findall("123abc123")==["123","123"]
(其实就是先定下一个规则，后面调用的时候就不必那么麻烦再次打入规则)

re.finditer(匹配规则，字符串)功能与findall一样，只不过finditer返回的是一个迭代器，需要用next()来获取数据，注意：这个时候需要这样写，next().group()，才能获取到我们想要的字符串数据。
整体可以这样写：
ret=re.finditer(规则，字符串)
next(ret).group()==数据



